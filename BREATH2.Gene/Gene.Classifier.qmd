---
title: "Gene.Classifier"
format: html
toc: true
---



# 1. Import Data

```{r}
#| warning: false




# 1.1. Import metadata


library(dplyr)
library(magrittr)

# Set directories
data_dir <- "C:/Users/User/Documents/UCSF/BREATH2.Gene/data"
results_dir <- "C:/Users/User/Documents/UCSF/BREATH2.Gene/results"

# Import metadata for proteomic and transcriptomic patients
metadata_df_ALL <- read.csv(
  file.path(data_dir, "sample_metadata.csv"),
  stringsAsFactors=F)

JCI_expanded_metadata <- read.csv(
  file.path(data_dir, "fixed_metadata_10242025.csv"),
  stringsAsFactors=F)

# Import protein matrix
vap_soma_normalized <- read.csv(
  file.path(data_dir, "vap_soma_normalized.csv"),
  stringsAsFactors=F)






# 1.2. Ready metadata table for LASSO


# Include only the 151 patients with both transcriptomic and proteomic data
patients_vector <- intersect(vap_soma_normalized$patient_id, 
                             JCI_expanded_metadata$SubjectID)

Prot.Data <- vap_soma_normalized[vap_soma_normalized$patient_id %in% patients_vector, ]
Meta.Data <- JCI_expanded_metadata[JCI_expanded_metadata$SubjectID %in% patients_vector, ]

# Ensures rows of Meta.Data match those of Prot.Data
Meta.Data <- Meta.Data[match(Prot.Data$patient_id, Meta.Data$SubjectID), ]

# Produces data frame with patients, age_in_years, sex, and LRTI_Adjudication
patient_info_ALL <- data.frame(
  sample_name = Meta.Data$sanitized_name,
  patient_id = Prot.Data$patient_id,
  sex = Meta.Data$sex,
  age_in_years = Meta.Data$age_in_years,
  LRTI_adjudication = Meta.Data$LRTI_adjudication,
  stringsAsFactors=F
)

# Restrict metadata_df to same 105 patients used in patient_info
metadata_df <- metadata_df_ALL %>%
  filter(sample_name %in% patient_info_ALL$sample_name) %>%
  filter(LRTI_adjudication %in% c("Definite", "No Evidence")) %>%
  left_join(patient_info_ALL %>% select(sample_name, patient_id),
    by = "sample_name") %>%
  relocate(patient_id, .after = sample_name)

# Write csv
write.csv(metadata_df, 
          file.path(data_dir, "metadata_df.csv"), 
          row.names=F)






# 1.3. Define workflow parameters


# Define parameters
Definite <- table(patient_info_ALL$LRTI_adjudication)["Definite"]
No_Evidence <- table(patient_info_ALL$LRTI_adjudication)["No Evidence"]
npatients <- Definite + No_Evidence
nfolds <- 5
ntrees <- 10000

# Store parameters as data frame
Parameters <- data.frame(c(npatients, Definite, No_Evidence, nfolds, ntrees))
row.names(Parameters) = c("Patients", "Definite", "No Evidence", "Folds", "RF Trees")
colnames(Parameters) = "Count"

write.csv(Parameters,
          file.path(data_dir, "parameters.csv"), 
          row.names=T)






# 1.4. Safety Check


print(Parameters)  

nrow(metadata_df)  # should be 105

sum(duplicated(metadata_df$sample_name))  # Should be 0

sum(is.na(Meta.Data$SubjectID))  # Should be 0






```


# 2. Fold Assignments

```{r}
#| warning: false






# 2.1. Import metadata


library(dplyr)
library(rsample)
library(magrittr)

# Read csvs
metadata_df <- read.csv(
  file.path(data_dir, "metadata_df.csv"), 
  stringsAsFactors=F)

Parameters <- read.csv(
  file.path(data_dir, "parameters.csv"),
  stringsAsFactors=F, row.names=1)

# Number of folds
nfolds <- as.numeric(Parameters["Folds", "Count"])

# Number of No Evidence patients
No_Evidence <- as.numeric(Parameters["No Evidence", "Count"])

# Minimum required per fold
min_NE_per_fold <- floor(No_Evidence / nfolds)






# 2.2. Fold Assignment Using rsample


folds_ok <- FALSE

# Set seed
set.seed(8634782)

# While loop enforcing constraints
while (!folds_ok) {

  # Stratified k-fold CV
  vfold_obj <- vfold_cv(
    data = metadata_df,
    v = nfolds,
    strata = "LRTI_adjudication"
  )

  # Add placeholder fold column (will be last column)
  metadata_df_with_folds <- metadata_df %>%
    mutate(fold = NA_integer_)

  # Fill fold assignments
  for (i in seq_len(nfolds)) {
    fold_indices <- vfold_obj$splits[[i]]$in_id
    val_indices <- setdiff(seq_len(nrow(metadata_df)), fold_indices)
    metadata_df_with_folds$fold[val_indices] <- i
  }

  # Count how many No Evidence cases per fold
  counts <- table(
    metadata_df_with_folds$fold,
    metadata_df_with_folds$LRTI_adjudication
  )

  # Check constraint
  if (all(counts[, "No Evidence"] >= min_NE_per_fold)) {
    folds_ok <- TRUE
  }
}

# Save output
write.csv(metadata_df_with_folds,
  file.path(data_dir, "metadata_df_with_folds.csv"),
  row.names=F)






# 2.3. Safety Check


print(counts)

print(min_NE_per_fold)






```


# 3. Lasso / VST

```{r}
#| warning: false






# 3.1. Import host counts & metadata


library(dplyr)
library(magrittr)
library(DESeq2)
library(glmnet)
library(tibble)
library(ggplot2)
library(knitr)

set.seed(8634782)

# Metadata with folds
metadata_df_with_folds <- read.csv(
  file.path(data_dir, "metadata_df_with_folds.csv"),
  stringsAsFactors=F)

# Host counts (remove gene_symbol col, rownames = ENSG)
host_counts <- read.csv(
  file.path(data_dir, "host_gene_counts.csv"),
  stringsAsFactors=F, row.names = 1)[, -1]

# Filter to samples used for CV
cv_host_counts <- host_counts[, metadata_df_with_folds$sample_name, drop = FALSE]

# Import parameters
Parameters <- read.csv(
  file.path(data_dir, "parameters.csv"),
  stringsAsFactors=F, row.names = 1)

# Call number of folds
nfolds <- as.numeric(Parameters["Folds", "Count"])

# Map ENSG to SYMBOL vector
ensg2gene <- read.csv(
  file.path(data_dir, "host_gene_counts.csv"),
  stringsAsFactors=F) %>%
  { `names<-`(.$gene_symbol, .$X) }






# 3.2. LASSO function


lasso_cv_outer_fold <- function(test_fold) {

  
  
  
    

# 3.2a. VST training samples ONLY
  

# Identify train/test samples
train_idx <- metadata_df_with_folds$fold != test_fold

# Extract training counts
train_counts <- cv_host_counts[, train_idx, drop = FALSE]

# Build DESeq2 object for training samples only
dds_train <- DESeq2::DESeqDataSetFromMatrix(
  countData = train_counts,
  colData = metadata_df_with_folds[train_idx, , drop = FALSE],
  design = ~1)

# Calculate size factors
dds_train <- DESeq2::estimateSizeFactors(dds_train)

dds_train <- DESeq2::estimateDispersions(dds_train)

# Apply VST to training samples only
vsd_train <- DESeq2::varianceStabilizingTransformation(dds_train, 
                                                       blind=F, 
                                                       fitType="parametric")

# Extract VST matrix
vsd_train_mat <- SummarizedExperiment::assay(vsd_train) %>% round(2)

# Create training X and y
X_train <- t(as.matrix(vsd_train_mat))            # training samples x genes
y_train <- (metadata_df_with_folds$LRTI_adjudication[train_idx] == "Definite")

  
  



# 3.2b. Find lambda that yields 3 genes per fold


  # Fit full lambda path
  fit <- glmnet::glmnet(
    X_train, y_train,
    family = "binomial",
    standardize = TRUE)

  # Count nonzero genes at each lambda
  nz <- apply(fit$beta, 2, function(b) sum(b != 0))
  
## Comment below for CV lasso

  # Lambda that selects exactly 3 genes
  #if (any(nz == 3)) {
    #lambda_k3 <- fit$lambda[which(nz == 3)[1]]   # largest lambda w/ 3 nonzero
  #} else {
    #idx <- which.min(abs(nz - 3))
    #lambda_k3 <- fit$lambda[idx]
  #}

## Comment above for CV lasso  
  
  
  


  
# 3.2c. Build VST on TEST samples ONLY
  
  
# Identify test samples  
test_idx <- metadata_df_with_folds$fold == test_fold

# Extract test counts
test_counts <- cv_host_counts[, test_idx, drop = FALSE]

dds_test <- DESeq2::DESeqDataSetFromMatrix(
  countData = test_counts[rownames(dds_train), , drop=FALSE],  # ensure same genes as train
  colData = metadata_df_with_folds[test_idx, , drop=FALSE],
  design = ~1
)

dds_test <- estimateSizeFactors(dds_test)

dispersionFunction(dds_test) <- dispersionFunction(dds_train)

# Apply frozen VST
vsd_test <- DESeq2::varianceStabilizingTransformation(dds_test, blind=F,
                                                      fitType="parametric")

# Extract VST matrix
vsd_test_mat <- SummarizedExperiment::assay(vsd_test) %>% round(2)

# Build X_test
X_test <- t(as.matrix(vsd_test_mat))

## Run below for CV lasso

# Cross-validated LASSO on training data
cv_fit <- cv.glmnet(
  X_train, y_train,
  family = "binomial",
  standardize = TRUE,
  nfolds = nfolds)

# Extract coefficients at lambda.1se
coefs_vec <- coef(fit, s = cv_fit$lambda.1se)[-1, 1]

# Keep only nonzero coefficients
nonzero <- coefs_vec[coefs_vec != 0]

## Run above for CV lasso

# Predictions for TEST FOLD ONLY (change lambda_k3 or cv_fit$lambda.1se)
pred_vec <- predict(fit, newx = X_test, type = "response", s = cv_fit$lambda.1se)[, 1]


# Build prediction data frame
preds <- data.frame(
  sample_name = colnames(test_counts),
  pred = pred_vec,
  stringsAsFactors=F)

  # Coefficients at selected lambda (change lambda_k3 or cv_fit$lambda.1se)
  coefs_vec <- coef(fit, s = cv_fit$lambda.1se)[-1, 1]

  nonzero <- coefs_vec[coefs_vec != 0]
  
  
  
  
  
  
# 3.2d. Ensure structure and build data frame
  
  
## Comment below for CV lasso  
  
  # Ensure at least 3 genes per fold
  #if (length(nonzero) < 3) {
    
  # Find all lambdas that select >= 3 nonzero genes
  #lambda_idx_candidates <- which(nz >= 3)
  #if (length(lambda_idx_candidates) == 0) {
    
    # If no lambda has >=3, pick lambda with closest >3 
    #idx <- which.min(abs(nz - 3))
    #lambda_k3 <- fit$lambda[idx]
  #} else {
    
    # Pick the largest lambda that yields at least 3 nonzero
    #lambda_k3 <- fit$lambda[lambda_idx_candidates[1]]
  #}
  
  # Extract coefficients at the new lambda
  #coefs_vec <- coef(fit, s = lambda_k3)[-1, 1]
  #nonzero <- coefs_vec[coefs_vec != 0]
  
  # If still >3, keep top 3 by absolute value
  #if (length(nonzero) > 3) {
    #top3 <- sort(abs(nonzero), decreasing = TRUE)[1]
    #nonzero <- nonzero[names(top3)]
  #}
#}

## Comment above for CV lasso  
  
  # Build fold-specific coefficient data frame
  nonzero_df <- data.frame(
    gene = names(nonzero),
    coef = as.numeric(nonzero),
    gene_symbol = ensg2gene[names(nonzero)],
    fold = test_fold, 
    stringsAsFactors=F
  )
  
  # Combine samples
  vsd_combined <- cbind(vsd_train_mat, vsd_test_mat)

  list(
    pred = preds,
    mod = fit, 
    coef = nonzero_df,
    vsd_cols = vsd_combined)
}






# 3.3. Run LASSO across folds


# Apply to all folds
lasso_results <- lapply(
  1:max(metadata_df_with_folds$fold),
  lasso_cv_outer_fold)

vsd_list <- lapply(lasso_results, `[[`, "vsd_cols")
full_vsd <- do.call(cbind, vsd_list)

# Ensures columns are in the same order as metadata
full_vsd <- full_vsd[, metadata_df_with_folds$sample_name, drop = FALSE]

stopifnot(!any(duplicated(colnames(full_vsd))))
stopifnot(all(colnames(full_vsd) == metadata_df_with_folds$sample_name))

# Save the matrix
write.csv(full_vsd,
          file.path(data_dir, "vst_combined_per_fold.csv"),
          row.names=T)

# Collect predictions and coefficients for each fold
lasso_preds <- lasso_results %>%
  lapply(function(x) x$pred) %>%
  bind_rows()

lasso_fold_coefs <- lasso_results %>%
  lapply(function(x) x$coef) %>%
  bind_rows()

# Save outputs
write.csv(
  lasso_preds,
  file.path(results_dir, "lasso_preds.csv"),
  row.names=F)

write.csv(
  lasso_fold_coefs,
  file.path(results_dir, "lasso_fold_coefs.csv"),
  row.names=F)






# 3.4. Safety Check


# Summary
print(table(lasso_fold_coefs$gene_symbol))

nrow(lasso_fold_coefs) 






# 3.5. Bar Graph


gene_freq <- table(lasso_fold_coefs$gene_symbol)

gene_df <- as.data.frame(gene_freq)

colnames(gene_df) = c("gene_symbol", "fold_freq")






# 3.5a. Gene frequency plot


# Plot gene frequencies
ggplot(
  gene_df %>% filter(gene_freq > 1),
  aes(
    x = reorder(gene_symbol, fold_freq),
    y = fold_freq
  )
) +
  geom_col(fill = "steelblue", width = 0.7) +
  scale_y_continuous(breaks = 1:5) +
  labs(
    title = "Genes Selected Across >1 Fold",
    x = NULL,
    y = "Number of folds selected"
  ) +
  theme_minimal(base_size = 14)






# 3.5b. Plot top 10 |coefs|


top10coefs <- lasso_fold_coefs %>% 
    slice_max(order_by = abs(lasso_fold_coefs$coef), n=10)

# Plot top coefs
ggplot(
  top10coefs,
  aes(
    x = coef,
    y = interaction(gene_symbol, fold, sep = " | ")
  )
) +
  geom_col(fill = "#d95f02", width = 0.7) +
  
  geom_text(
  aes(label = round(coef, 3)),
  hjust = ifelse(top10coefs$coef > 0, -0.1, 1.1),
  size = 4
) +
  
  scale_x_continuous(
    limits = c(-1.5, 1.5),
    breaks = seq(-1.5, 1.5, by = 0.5)
  ) +
  scale_y_discrete(limits = sort) +
  labs(
    title = "Top 10 Genes by |coef|",
    x = "Coefficient",
    y = NULL
  ) +
  theme_minimal(base_size = 14)






```


# 4. Random Forest

```{r}
#| warning: false






# 4.1. Import Data for RF


library(dplyr)
library(magrittr)
library(randomForest)
library(tibble)
library(DESeq2)    
library(SummarizedExperiment)

set.seed(8634782)

# Import data
metadata_df_with_folds <- read.csv(
  file.path(data_dir, "metadata_df_with_folds.csv"),
  stringsAsFactors=F)

full_vsd <- read.csv(
  file.path(data_dir, "vst_combined_per_fold.csv"),
  stringsAsFactors=F, row.names=1)

Parameters <- read.csv(
  file.path(data_dir, "parameters.csv"),
  stringsAsFactors=F, row.names=1)

# Define ntrees 
ntrees <- as.numeric(Parameters["RF Trees", "Count"])

# Import selected proteins
lasso_fold_coefs <- read.csv(
  file.path(results_dir, "lasso_fold_coefs.csv"), 
  stringsAsFactors=F)

# Use lasso_fold_coefs as selected genes
selected_lasso_coefs <- lasso_fold_coefs






# 4.2. RF function


# Outcome variable
y <- as.factor(metadata_df_with_folds$LRTI_adjudication)  

# Function to run Random Forest for one outer CV fold
lassoRF_cv_outer_fold <- function(test_fold) {
  
  # Extract proteins selected by LASSO for this fold
  keep <- selected_lasso_coefs %>%
            filter(fold == test_fold) %>%
            .$gene

  # Boolean for training samples
  train <- metadata_df_with_folds$fold != test_fold
  test  <- metadata_df_with_folds$fold == test_fold

  
  
  
  
  
# 4.2a. Use precomputed vst from LASSO
  
  
# full_vsd is genes x samples — transpose to samples x genes
X_all <- t(as.matrix(full_vsd))

# Ensure X_all row order matches metadata order
X_all <- X_all[metadata_df_with_folds$sample_name, , drop = FALSE]

# training / test matrices
X_train <- X_all[train, keep, drop = FALSE]
X_test  <- X_all[test, keep, drop = FALSE]

stopifnot(all(colnames(X_train) %in% selected_lasso_coefs$gene))

  # Fit Random Forest (10000 Trees)
  rf <- randomForest(X_train, y[train], ntree = ntrees)
  
  # Predictions on test fold
  preds <- predict(rf, newdata = X_test, type = "prob")[, "Definite"]
  
  list(test_fold = test_fold, mod = rf, pred = preds)
}

# Run RF across all folds
cv_list <- lapply(1:max(metadata_df_with_folds$fold), lassoRF_cv_outer_fold)






# 4.3. Collect preds


# Collect out-of-fold predictions for all samples
rf_preds <- cv_list %>%
  lapply(function(x) {
    data.frame(
      sample_name = metadata_df_with_folds$sample_name[
        metadata_df_with_folds$fold == x$test_fold],
      pred = x$pred
    )
  }) %>%
  bind_rows() %>%
  dplyr::left_join(
  dplyr::select(metadata_df_with_folds, sample_name, LRTI_adjudication),
    by = "sample_name"
  ) %>%
  dplyr::relocate(LRTI_adjudication, .after = sample_name)

# Save RF predictions
write.csv(rf_preds, 
          file.path(results_dir, "lassoRF_preds.csv"),
          row.names=F)






# 4.4. Collect votes


# Collect RF votes (training set OOB probabilities)
rf_votes <- cv_list %>%
  lapply(function(x) {
    as.data.frame(x$mod$votes) %>%
      tibble::rownames_to_column("sample_name") %>%
      mutate(test_fold = x$test_fold) %>%
      mutate(pred = .data[["Definite"]]) %>%
      dplyr::select(test_fold, sample_name, pred)
  }) %>%
  bind_rows() %>%
  dplyr::left_join(
  dplyr::select(metadata_df_with_folds, sample_name, LRTI_adjudication),
    by = "sample_name"
  ) %>%
  dplyr::relocate(LRTI_adjudication, .after = sample_name)

# Save votes
write.csv(rf_votes, 
          file.path(results_dir, "lassoRF_votes.csv"),
          row.names=F)






# 4.5. Safety Check


# Summary
table(selected_lasso_coefs$gene_symbol)

nrow(rf_preds) == nrow(metadata_df_with_folds) # Should return TRUE






```


# 5. ROC Curve

```{r}
#| warning: false






# 5.1. Import metadata & preds


library(dplyr)
library(magrittr)
library(pROC)

# Import fold assignments
metadata_df_with_folds <- read.csv(
  file.path(data_dir, "metadata_df_with_folds.csv"),
  stringsAsFactors=F)

# Import out-of-fold predictions
lassoRF_preds <- read.csv(
  file.path(results_dir, "lassoRF_preds.csv"),
  stringsAsFactors=F)

# Ensure consistent factor levels
lassoRF_preds$LRTI_adjudication <- factor(
  lassoRF_preds$LRTI_adjudication,
  levels = c("No Evidence", "Definite")
)

# Merge
merged_preds <- lassoRF_preds %>%
  dplyr::inner_join(
    metadata_df_with_folds %>% 
  dplyr::select(sample_name, fold),
    by = "sample_name"
  )






# 5.2. Per-fold AUC


output_auc_roc <- function(preds_df, output_suffix) {

  # Compute per-fold AUC
  auc_df <- preds_df %>%
    group_by(fold) %>%
    summarize({
  roc_obj <- pROC::roc(
    response  = factor(LRTI_adjudication, levels = c("No Evidence", "Definite")),
    predictor = pred,
    direction = "<"
  )
  ci_vals <- pROC::ci.auc(roc_obj, conf.level = 0.95)
  tibble(
    auc = as.numeric(roc_obj$auc),
    auc_lower = ci_vals[1],
    auc_upper = ci_vals[3]
  )
}, .groups = "drop")

  # Determine number of folds
  max_fold <- max(auc_df$fold)

  # Create ROC PDF (all folds overlayed)
  pdf(file.path(results_dir, paste0("ROC_", output_suffix, ".pdf")))

  for (i in 1:max_fold) {
    fold_data <- preds_df %>% filter(fold == i)

    roc_obj <- pROC::roc(
      response  = factor(fold_data$LRTI_adjudication, levels = c("No Evidence", "Definite")),
      predictor = fold_data$pred,
      direction = "<"
    )

    plot(roc_obj, add = (i != 1), col = i)
  }

  dev.off()

  # Save per-fold AUC CSV at the very end (safer if plotting errors occur)
  write.csv(
    auc_df,
    file.path(results_dir, paste0("cv_auc_", output_suffix, ".csv")),
    row.names=F)

  return(auc_df)
}






# 5.3. Plot Graph


# Run AUC computation
auc_lassoRF <- output_auc_roc(merged_preds, "lassoRF")

max_fold <- max(auc_lassoRF$fold)

# Open empty plot for overlay with top-left orientation
plot(0, 0, type = "n",
     xlim = c(1, 0), ylim = c(0, 1),
     xlab = "Specificity", ylab = "Sensitivity",
     main = "ROC Curves by Fold")

# Add diagonal reference
lines(x = c(1, 0), y = c(0, 1), lty = 2, col = "gray")

for (i in 1:max_fold) {
  fold_data <- merged_preds %>% filter(fold == i)

  roc_obj <- pROC::roc(
    response  = factor(fold_data$LRTI_adjudication, levels = c("No Evidence", "Definite")),
    predictor = fold_data$pred,
    direction = "<"
  )

  # Plot specificity directly: axis direction flips via xlim
  lines(roc_obj$specificities, roc_obj$sensitivities, col = i, lwd = 2)
}

legend("bottomright", legend = paste("Fold", 1:max_fold), col = 1:max_fold, lwd = 2)






# 5.4. Summaries


# DeLong 95% CI for overall ROC
ci_auc <- pROC::ci.auc(
  pROC::roc(
    response = factor(merged_preds$LRTI_adjudication, 
    levels = c("No Evidence", "Definite")),
    predictor = merged_preds$pred,
    direction = "<"
  ),
  conf.level = 0.95
)

message("Lower AUC: ", round(ci_auc[1], 3))
message("Mean AUC: ", round(as.numeric(ci_auc[2]), 3))
message("Upper AUC: ", round(ci_auc[3], 3))

print(auc_lassoRF)






```


# 6. Differential Expression

```{r}
#| warning: false






# 6.1. Import data


library(DESeq2)
library(ggplot2)
library(ggrepel)   
library(dplyr)
library(apeglm)
library(tidyr)
library(tibble)

# Metadata with folds
metadata_df_with_folds <- read.csv(
  file.path(data_dir, "metadata_df_with_folds.csv"),
  stringsAsFactors=F)

# Host counts (remove gene_symbol col, rownames = ENSG)
host_counts <- read.csv(
  file.path(data_dir, "host_gene_counts.csv"),
  stringsAsFactors=F, row.names = 1)[, -1]

# Filter to Defiite / No Evidence patients
cv_host_counts <- host_counts[, metadata_df_with_folds$sample_name, drop = FALSE]

# Map ENSG → SYMBOL vector
ensg2gene <- read.csv(
  file.path(data_dir, "host_gene_counts.csv"),
  stringsAsFactors=F) %>%
  { `names<-`(.$gene_symbol, .$X) }






# 6.2. DESeq2


# Build DESeq dataset 
dds <- DESeqDataSetFromMatrix(
  countData = cv_host_counts,
  colData   = metadata_df_with_folds %>% column_to_rownames("sample_name"),
  design    = ~ LRTI_adjudication)

# Filter low count genes
keep <- rowSums(counts(dds) > 10) > 0.2 * ncol(counts(dds))
dds <- dds[keep, ]

# Run DESeq 
dds <- DESeq(dds)

# Get results (Definite vs No Evidence)
res <- results(dds, contrast = c("LRTI_adjudication", "Definite", "No Evidence"))

resultsNames(dds)

resLFC <- lfcShrink(dds, coef="LRTI_adjudication_No.Evidence_vs_Definite", type="apeglm")

res_df <- as.data.frame(resLFC) %>%
  rownames_to_column("gene") %>%
  mutate(
    padj = ifelse(is.na(padj), 1, padj),
    log2FoldChange = ifelse(is.na(log2FoldChange), 0, log2FoldChange),
    negLog10P = -log10(pvalue + 1e-300) )

# Normalized RNA expr.
rna_norm <- counts(dds, normalized = TRUE) %>%
  as.data.frame() %>%
  rownames_to_column("gene")

# Map ENSG to gene symbol
rna_norm$gene_symbol <- ensg2gene[rna_norm$gene]
rna_norm$gene_symbol[is.na(rna_norm$gene_symbol)] <- rna_norm$gene

write.csv(
  rna_norm,
  file.path(results_dir, "rna_norm.csv"),
  row.names=F)






# 6.3. Volcano Plot


# Flip LFC so positive = Definite (even though coef was reversed)
res_df$log2FoldChange <- -res_df$log2FoldChange






# 6.3a. Plot content


# Add gene symbols
res_df$gene_symbol <- ensg2gene[res_df$gene]
res_df$gene_symbol[is.na(res_df$gene_symbol)] <- res_df$gene

# Compute significance
res_df <- res_df %>%
  mutate(sig = padj < 0.05 & abs(log2FoldChange) >= 1)

# Define biological direction (for point color)
res_df <- res_df %>%
  mutate(direction = case_when(
    log2FoldChange > 1 ~ "Definite",
    log2FoldChange < -1 ~ "NoEvidence",
    abs(log2FoldChange) <= 1 ~ "Neutral"
  ))

# Top 10 in each direction
top_definite  <- res_df %>% filter(direction=="Definite")  %>% arrange(padj) %>% head(10)
top_noEvidence <- res_df %>% filter(direction=="NoEvidence") %>% arrange(padj) %>% head(10)

top_labels <- bind_rows(top_definite, top_noEvidence)






# 6.3b. ggplot


ggplot(res_df, aes(x = log2FoldChange, y = negLog10P)) +
  geom_point(aes(color = direction), alpha = 0.6) +
  scale_color_manual(values = c(
    "Definite" = "blue",
    "NoEvidence" = "red",
    "Neutral" = "grey70"
  )) +
  geom_vline(xintercept = c(-1, 1), linetype = "dashed") +
  geom_hline(yintercept = -log10(0.05), linetype = "dashed") +
  theme_minimal() +
  labs(x = "log2 Fold Change",
       y = "-log10(p-value)",
       title = "Volcano plot - host counts") +
  geom_text_repel(
    data = top_labels,
    aes(label = gene_symbol),
    size = 3,
    max.overlaps = 30)

# Save results
write.csv(res_df,
          file.path(results_dir, "DESeq2_results_transcriptome.csv"),
          row.names=F)

ggsave(file.path(results_dir, "volcano_transcriptome.png"), 
       width = 8, height = 6)






```


# 7. RNA vs. protein concordance plot

```{r}
#| warning: false






# 7.1. Import data


library(dplyr)
library(ggplot2)
library(ggrepel)
library(openxlsx)

# Import data
rna_res <- read.csv(
  file.path(results_dir, "DESeq2_results_transcriptome.csv"),
  stringsAsFactors=F)

prot_res <- read.csv(
  file.path("C:/Users/User/Documents/UCSF/BREATH2.Prot/results/DA_results_proteomics.csv"),
  stringsAsFactors=F)






# 7.2. Merge IDs


# rna df
rna_df <- rna_res %>%
  dplyr::select(
    gene_symbol,
    log2FC_RNA = log2FoldChange,
    padj_RNA = padj
  ) %>%
  filter(!is.na(gene_symbol))

# prot df
prot_df <- prot_res %>%
  dplyr::select(
    gene_symbol = gene,
    log2FC_protein = log2FoldChange,
    padj_protein = padj
  )

# Restrict to genes/proteins in both data frames
merged_df <- inner_join(rna_df, prot_df, by = "gene_symbol")

# Define significance class
merged_df <- merged_df %>%
  mutate(
    sig_class = case_when(
      padj_RNA < 0.05 & padj_protein < 0.05 ~ "Both",
      padj_RNA < 0.05 ~ "RNA only",
      padj_protein < 0.05 ~ "Protein only",
      TRUE ~ "Neither")) %>%
  mutate(
    point_size = ifelse(sig_class == "Both", 2.2, 1.1))






# 7.3. Correlation values


cor_spearman <- cor(
  merged_df$log2FC_RNA,
  merged_df$log2FC_protein,
  method = "spearman"
)

cor_spearman

# Conditional correlation: features significant in both RNA and protein
cor_spearman_both <- cor(
  merged_df %>% filter(sig_class == "Both") %>% pull(log2FC_RNA),
  merged_df %>% filter(sig_class == "Both") %>% pull(log2FC_protein),
  method = "spearman"
)

cor_spearman_both






# 7.4. Prepare plot content


label_df <- merged_df %>%
  filter(sig_class == "Both") %>%
  mutate(
    concordance = abs(log2FC_RNA) + abs(log2FC_protein),
    quadrant = case_when(
      log2FC_RNA > 0 & log2FC_protein > 0 ~ "URQ",
      log2FC_RNA < 0 & log2FC_protein < 0 ~ "RLQ",
      TRUE ~ "Other"
    )
  ) %>%
  
  # Ensure strong concordant signals are always labeled
  group_by(quadrant) %>%
  slice_max(concordance, n = 4) %>%   # 4 URQ + 4 RLQ
  ungroup() %>%
  
  # Add strongest remaining signals overall
  bind_rows(
    merged_df %>%
      filter(sig_class == "Both") %>%
      mutate(concordance = abs(log2FC_RNA) + abs(log2FC_protein)) %>%
      slice_max(concordance, n = 12)
  ) %>%
  distinct(gene_symbol, .keep_all = TRUE)






# 7.5. RNA vs. Protein concordance plot


ggplot(
  merged_df,
  aes(x = log2FC_RNA, y = log2FC_protein, color = sig_class)
) +
  geom_point(aes(size = point_size), alpha = 0.6) +
  scale_size_identity() +
  geom_text_repel(
  data = label_df,
  aes(label = gene_symbol),
  size = 3,
  box.padding = 0.4,
  segment.color = "grey70",
  max.overlaps = 20
) +
  geom_hline(yintercept = 0, linetype = "dashed", color = "grey60") +
  geom_vline(xintercept = 0, linetype = "dashed", color = "grey60") +
  scale_color_manual(values = c(
    "Both" = "purple",
    "RNA only" = "blue",
    "Protein only" = "red",
    "Neither" = "grey70"
  )) +
  theme_classic() +
  labs(
  x = "log2 Fold Change (Transcriptome)",
  y = "log2 Fold Change (Proteome)",
  title = "RNA–Protein Concordance of LRTI-Associated Features",
  subtitle = paste0(
    "All features: Spearman \u03C1 = ", round(cor_spearman, 2),
    " | Jointly significant: \u03C1 = ",
    round(cor_spearman_both, 2),
    " (n = ", nrow(merged_df), ")"
  ),
  color = "Significance"
)

ggsave(
  file.path(results_dir, "loglog_RNA_protein_LFC.png"),
  width = 7,
  height = 6
)

write.xlsx(merged_df,
           file.path(results_dir, "lfc_rna_protein_concordance.xlsx"))






```


# 8. RNA vs. protein loglog abundance plot

```{r}
#| warning: false






# 8.1. Import data


library(dplyr)
library(tidyr)
library(ggplot2)
library(ggrepel)
library(tibble)

# RNA vst matrix (genes x samples)
full_vsd <- read.csv(
  file.path(data_dir, "vst_combined_per_fold.csv"),
  row.names = 1
)

# Protein log2-normalized abundances matrix (samples x proteins)
protein_mat <- read.csv(
  "C:/Users/User/Documents/UCSF/BREATH2.Prot/data/protein_mat.csv",
  row.names = 1
)






# 8.2. Prepare RNA


rna_mean <- full_vsd %>%
  as.data.frame() %>%
  rownames_to_column("gene") %>%
  mutate(gene_symbol = ensg2gene[gene]) %>%
  mutate(gene_symbol = ifelse(is.na(gene_symbol), gene, gene_symbol)) %>%
  dplyr::select(-gene) %>%
  pivot_longer(
    cols = -gene_symbol,
    names_to = "sample_name",
    values_to = "expr_vst"
  ) %>%
  group_by(gene_symbol) %>%
  summarize(
    mean_rna_vst = mean(expr_vst, na.rm = TRUE),
    .groups = "drop"
  )






# 8.3. Prepare protein


protein_mean <- protein_mat %>%
  as.data.frame() %>%
  rownames_to_column("patient_id") %>%
  pivot_longer(
    cols = -patient_id,
    names_to = "gene_symbol",
    values_to = "protein_log2"
  ) %>%
  group_by(gene_symbol) %>%
  summarize(
    mean_protein_log2 = mean(protein_log2, na.rm = TRUE),
    .groups = "drop"
  )




# 8.4. Merge RNA with protein


loglog_df <- inner_join(
  rna_mean,
  protein_mean,
  by = "gene_symbol"
)

# Identify top genes by combined mean abundance (RNA + protein)
label_df <- loglog_df %>%
  mutate(total_abundance = mean_rna_vst + mean_protein_log2) %>%
  arrange(desc(total_abundance)) %>%
  head(20)   # top 20 most abundant genes

# Correlation
cor_spearman <- cor(
  loglog_df$mean_rna_vst,
  loglog_df$mean_protein_log2,
  method = "spearman"
)






# 8.5. Log-log abundance plot


ggplot(
  loglog_df,
  aes(x = mean_rna_vst, y = mean_protein_log2)
) +
  geom_point(alpha = 0.25, size = 1, color = "grey30") +
  geom_smooth(method = "lm", se = FALSE, color = "firebrick", linewidth = 0.8) +
  geom_text_repel(
  data = label_df,
  aes(label = gene_symbol),
  size = 3,
  max.overlaps = 20,
  box.padding = 0.4,
  segment.color = "grey70"
) +
  theme_classic() +
  labs(
    x = "Mean RNA expression (VST)",
    y = "Mean protein abundance (log2)",
    title = "RNA–Protein Abundance Relationship",
    subtitle = paste0(
      "Spearman \u03C1 = ", round(cor_spearman, 2),
      " | n = ", nrow(loglog_df)
    )
  )

ggsave(
  file.path(results_dir, "RNA_protein_loglog_abundance.png"),
  width = 7,
  height = 6
)






```


# 9. Pathway Analysis

```{r}
#| warning: false






# 9.1. Import data


library(clusterProfiler)
library(msigdbr)
library(org.Hs.eg.db)
library(dplyr)
library(ggplot2)
library(stringr)
library(enrichplot)

rna_res <- read.csv(
  file.path(results_dir, "DESeq2_results_transcriptome.csv"),
  stringsAsFactors=F)






# 9.2. Ranked Genes List


# Use gene symbols and log2FC
gsea_df <- res_df %>%
  filter(!is.na(gene_symbol)) %>%
  distinct(gene_symbol, .keep_all = TRUE)

# Named numeric vector: log2FC, names = gene symbols
gene_ranks <- gsea_df$log2FoldChange
names(gene_ranks) <- gsea_df$gene_symbol

# Sort decreasing (required)
gene_ranks <- sort(gene_ranks, decreasing = TRUE)






# 9.3. Hallmark GSEA


hallmark_sets <- msigdbr(
  species  = "Homo sapiens",
  category = "H"
) %>%
  dplyr::select(gs_name, gene_symbol)

gsea_hallmark <- GSEA(
  geneList     = gene_ranks,
  TERM2GENE    = hallmark_sets,
  pvalueCutoff = 0.05,
  eps          = 0,
  verbose      = FALSE
)

hallmark_df <- as.data.frame(gsea_hallmark)

write.csv(hallmark_df,
  file.path(results_dir, "GSEA_Hallmark_transcriptome.csv"),
  row.names=F)






# 9.4. Reactome GSEA


reactome_sets <- msigdbr(
  species     = "Homo sapiens",
  category    = "C2",
  subcategory = "CP:REACTOME"
) %>%
  dplyr::select(gs_name, gene_symbol)

gsea_reactome <- GSEA(
  geneList     = gene_ranks,
  TERM2GENE    = reactome_sets,
  pvalueCutoff = 0.05,
  verbose      = FALSE
)

reactome_df <- as.data.frame(gsea_reactome)

write.csv(
  reactome_df,
  file.path(results_dir, "GSEA_Reactome_transcriptome.csv"),
  row.names=F)




# 9.5. Hallmark Pathway Plot


# View top Hallmark pathways by magnitude of enrichment
gsea_hallmark@result %>%
  filter(p.adjust < 0.05) %>%
  arrange(desc(abs(NES))) %>%
  dplyr::select(ID, Description, NES, p.adjust) %>%
  head(10)

gseaplot2(
  gsea_hallmark,
  geneSetID = "HALLMARK_INTERFERON_GAMMA_RESPONSE",
  title = "Hallmark IFNγ Response – Transcriptome",
  base_size = 12
)

gseaplot2(
  gsea_hallmark,
  geneSetID = "HALLMARK_INTERFERON_ALPHA_RESPONSE",
  title = "Hallmark IFNα Response – Transcriptome",
  base_size = 12
)

# IFNγ
p_ifng <- gseaplot2(
  gsea_hallmark,
  geneSetID = "HALLMARK_INTERFERON_GAMMA_RESPONSE",
  title = "Hallmark IFNγ Response",
  base_size = 12,
  subplots = c(1, 2, 3),   
  pvalue_table = TRUE     # adds NES, p, FDR
) +
  theme(
    plot.title = element_text(hjust = 0.5, face = "bold")
  )

# IFNα
p_ifna <- gseaplot2(
  gsea_hallmark,
  geneSetID = "HALLMARK_INTERFERON_ALPHA_RESPONSE",
  title = "Hallmark IFNα Response",
  base_size = 12,
  subplots = c(1, 2, 3),
  pvalue_table = TRUE
) +
  theme(
    plot.title = element_text(hjust = 0.5, face = "bold")
  )

# Print plots
p_ifng
p_ifna

# Save plots
ggsave(
  file.path(results_dir, "GSEA_IFNG_transcriptome.png"),
  p_ifng,
  width = 7,
  height = 6
)

ggsave(
  file.path(results_dir, "GSEA_IFNA_transcriptome.png"),
  p_ifna,
  width = 7,
  height = 6
)






# 9.6. Reactome Pathway Plot


gsea_reactome@result %>%
  arrange(desc(abs(NES))) %>%
  head(20) %>%
  dplyr::select(ID, Description, NES, p.adjust)

p_reactome_ifn <- gseaplot2(
  gsea_reactome,
  geneSetID = "REACTOME_INTERFERON_ALPHA_BETA_SIGNALING",
  title = "Reactome IFNα/β Signaling – Transcriptome",
  base_size = 12
)

# Print plot
p_reactome_ifn

# Save plot
ggsave(
  filename = file.path(results_dir, "GSEA_Reactome_IFN_alpha_beta.png"),
  plot = p_reactome_ifn,
  width = 7,
  height = 6,
  dpi = 300
)






# 9.7. Hallmark GSEA summary dot plot


hallmark_plot_df <- gsea_hallmark@result %>%
  filter(p.adjust < 0.05) %>%
  mutate(
    neglogPadj = -log10(p.adjust),
    Direction = ifelse(NES > 0, "Up", "Down"),
    Description = factor(
      Description,
      levels = Description[order(NES)]
    )
  )

p_hallmark_all <- ggplot(
  hallmark_plot_df,
  aes(y = Description, x = NES)
) +
  # Center line (NES = 0)
  geom_vline(xintercept = 0, linewidth = 0.8, color = "black") +

  # Stems
  geom_segment(
    aes(x = 0, xend = NES, yend = Description),
    linewidth = 0.7,
    color = "grey60"
  ) +

  # OPTION 1: COLOR BY padj
  #geom_point(
    #aes(color = neglogPadj),
    #size = 4
  #) +
  #scale_color_viridis_c(
    #name = expression(-log[10]~padj),
    #option = "C"
  #) +

  # OPTION 2: COLOR BY DIRECTION
   geom_point(
     aes(color = Direction),
     size = 4
   ) +
   scale_color_manual(
     values = c("Up" = "red3", "Down" = "blue3"),
     name = "Enrichment direction"
   ) +

  theme_classic(base_size = 12) +
  theme(
    
    # Center title across entire figure
    plot.title.position = "plot",
    plot.title = element_text(hjust = 0.5, face = "bold"),
    plot.subtitle = element_text(hjust = 0.5),

    # Add right margin so labels don't clip
    plot.margin = ggplot2::margin(t = 10, r = 40, b = 10, l = 10)
  ) +
  labs(
    title = "Hallmark Pathway Enrichment (GSEA)",
    subtitle = "Transcriptome; pathways ordered by normalized enrichment score",
    x = "Normalized Enrichment Score (NES)",
    y = NULL
  ) +
  xlim(-5, 5)

# Print plot
p_hallmark_all

# Save plot
ggsave(
  filename = file.path(results_dir, "GSEA_Hallmark_all_pathways.png"),
  plot = p_hallmark_all,
  width = 8,
  height = 6,
  dpi = 300
)






# 9.8. Reactome GSEA summary dot plot


reactome_plot_df <- gsea_reactome@result %>%
  filter(p.adjust < 0.05) %>%
  mutate(
    neglogPadj = -log10(p.adjust),
    Direction = ifelse(NES > 0, "Up", "Down")
  )

# Top 10 UP (positive NES)
reactome_top_up <- reactome_plot_df %>%
  filter(NES > 0) %>%
  arrange(desc(NES)) %>%
  slice_head(n = 8)  # top 10

# Top 10 DOWN (negative NES)
reactome_top_down <- reactome_plot_df %>%
  filter(NES < 0) %>%
  arrange(NES) %>%      
  slice_head(n = 8)  # top 10 negative

reactome_top20 <- bind_rows(reactome_top_up, reactome_top_down) %>%
  mutate(
    Description = gsub("_", " ", Description),
    Description = str_wrap(Description, width = 40),
    Description = factor(Description, levels = Description[order(NES)])
  )

# Check
reactome_top20 %>% dplyr::select(Description, NES, neglogPadj, Direction)

# Plot
p_reactome_top20 <- ggplot(
  reactome_top20,
  aes(y = Description, x = NES)
) +
  # Center line (NES = 0)
  geom_vline(xintercept = 0, linewidth = 0.8, color = "black") +

  # Stems
  geom_segment(
    aes(x = 0, xend = NES, yend = Description),
    linewidth = 0.7,
    color = "grey60"
  ) +

  # Dots colored by Direction (Up = red, Down = blue)
  geom_point(
    aes(color = Direction),
    size = 4
  ) +
  scale_color_manual(
    values = c("Up" = "red3", "Down" = "blue3"),
    name = "Enrichment direction"
  ) +

  # Styling
  theme_classic(base_size = 12) +
  theme(
    axis.text.y = element_text(size = 9),  # smaller font
    # Center title across entire figure
    plot.title.position = "plot",
    plot.title = element_text(hjust = 0.5, face = "bold"),
    plot.subtitle = element_text(hjust = 0.5),
    # Add right margin so labels don't clip
    plot.margin = ggplot2::margin(t = 10, r = 40, b = 10, l = 10)
  ) +
  labs(
    title = "Reactome Pathway Enrichment (GSEA)",
    subtitle = "Transcriptome; top 8 up and top 8 down pathways",
    x = "Normalized Enrichment Score (NES)",
    y = NULL
  ) +
  xlim(-5, 5)

# Print plot
p_reactome_top20

# Save plot
ggsave(
  filename = file.path(results_dir, "GSEA_Reactome_top20_pathways.png"),
  plot = p_reactome_top20,
  width = 8,
  height = 8,
  dpi = 300
)






# 9.9. RNA vs Protein PA dot plot


protein_ranks_df <- read.csv(
  file.path(
    "C:/Users/User/Documents/UCSF/BREATH2.Prot/results/protein_ranks_for_RNA_GSEA.csv"),
  stringsAsFactors=F)

protein_ranks <- protein_ranks_df$log2FC
names(protein_ranks) <- protein_ranks_df$gene

# Re-sort
protein_ranks <- sort(protein_ranks, decreasing = TRUE)

gsea_hallmark_rna_all <- GSEA(
  geneList     = gene_ranks,
  TERM2GENE    = hallmark_sets,
  pvalueCutoff = 1,
  eps          = 0,
  verbose      = FALSE
)

gsea_hallmark_prot_all <- GSEA(
  geneList     = protein_ranks,
  TERM2GENE    = hallmark_sets,
  pvalueCutoff = 1,
  eps          = 0,
  verbose      = FALSE
)






# 9.9a. Hallmark RNA and protein


rna_df <- gsea_hallmark_rna_all@result %>%
  dplyr::select(
    ID,
    Description,
    NES_rna = NES,
    padj_rna = p.adjust
  )

prot_df <- gsea_hallmark_prot_all@result %>%
  dplyr::select(
    ID,
    NES_prot = NES,
    padj_prot = p.adjust
  )

hallmark_compare_df <- full_join(
  rna_df,
  prot_df,
  by = "ID"
) %>%
  mutate(
    combined_abs_NES = abs(NES_rna) + abs(NES_prot)
  )

hallmark_to_plot <- hallmark_compare_df %>%
  arrange(desc(combined_abs_NES)) %>%
  slice_head(n = 16)

hallmark_to_plot %>%
  dplyr::select(
    Description,
    NES_rna,
    NES_prot,
    padj_rna,
    padj_prot
  )






# 9.9b. Plot content


plot_df <- hallmark_to_plot %>%
  dplyr::select(
    ID, Description,
    NES_rna, padj_rna,
    NES_prot, padj_prot
  ) %>%
  pivot_longer(
    cols = c(NES_rna, NES_prot),
    names_to = "Omics",
    values_to = "NES"
  ) %>%
  mutate(
    padj = ifelse(Omics == "NES_rna", padj_rna, padj_prot),
    Omics = ifelse(Omics == "NES_rna", "RNA", "Protein"),

    # Significance flag 
    Significant = padj < 0.05,

    # Clean pathway names
    Description = str_wrap(gsub("_", " ", Description), width = 40)
  )

omics_colors <- c(
  "RNA" = "#4C72B0",      # muted blue
  "Protein" = "#55A868"  # muted green
)






# 9.9c. Dot plot


p_compare <- ggplot(
  plot_df,
  aes(y = Description, x = NES, color = Omics)
) +
  # Center line
  geom_vline(xintercept = 0, linewidth = 0.8, color = "black") +

  # Stems
  geom_segment(
    aes(x = 0, xend = NES, yend = Description),
    linewidth = 0.55,
    color = "grey75"
  ) +

  # Thick black outline for significant points
  geom_point(
    data = subset(plot_df, Significant),
    shape = 21,
    size = 5.4,        # larger ring
    fill = NA,
    color = "black",
    linewidth = 1.6    # much thicker outline
  ) +

  # Filled points
  geom_point(
    aes(fill = Omics),
    shape = 21,
    size = 4.2
  ) +

  scale_fill_manual(values = omics_colors) +
  scale_color_manual(values = omics_colors) +

  theme_classic(base_size = 12) +
  theme(
    axis.text.y = element_text(size = 9),
    plot.title.position = "plot",
    plot.title = element_text(hjust = 0.5, face = "bold"),
    plot.subtitle = element_text(hjust = 0.5),
    legend.position = "top",
    plot.margin = margin(t = 8, r = 20, b = 8, l = 10)
  ) +
  labs(
    title = "Hallmark Pathway Enrichment: RNA vs Protein",
    subtitle = "Top pathways ranked by combined |NES|\nBlack circle = padj < 0.05",
    x = "Normalized Enrichment Score (NES)",
    y = NULL,
    fill = "Omics layer",
    color = "Omics layer"
  ) +
  xlim(-2.5, 4.5)

# Print plot
p_compare

# Save plot
ggsave(
  filename = file.path(results_dir, "GSEA_Hallmark_RNA_vs_Protein.png"),
  plot = p_compare,
  width = 8,
  height = 7,
  dpi = 300
)






```


# 10. Supplemental Plots

```{r}
#| warning: false





# 10.1. Import data


library(clusterProfiler)
library(msigdbr)
library(org.Hs.eg.db)
library(dplyr)
library(ggplot2)
library(stringr)
library(enrichplot)

rna_res <- read.csv(
  file.path(results_dir, "DESeq2_results_transcriptome.csv"),
  stringsAsFactors=F)

# Use gene symbols and log2FC
gsea_df <- res_df %>%
  filter(!is.na(gene_symbol)) %>%
  distinct(gene_symbol, .keep_all = TRUE)

# Named numeric vector: log2FC, names = gene symbols
gene_ranks <- gsea_df$log2FoldChange
names(gene_ranks) <- gsea_df$gene_symbol

# Sort decreasing (required)
gene_ranks <- sort(gene_ranks, decreasing = TRUE)

hallmark_sets <- msigdbr(
  species  = "Homo sapiens",
  category = "H"
) %>%
  dplyr::select(gs_name, gene_symbol)

gsea_hallmark <- GSEA(
  geneList     = gene_ranks,
  TERM2GENE    = hallmark_sets,
  pvalueCutoff = 0.05,
  eps          = 0,
  verbose      = FALSE
)






# 10.2. Hallmark IL6 JAK STAT3 Signaling


p_il6_jak <- gseaplot2(
  gsea_hallmark,
  geneSetID = "HALLMARK_IL6_JAK_STAT3_SIGNALING",
  title = "Hallmark IL6 JAK STAT3 Signaling",
  base_size = 12,
  subplots = c(1, 2, 3))

p_il6_jak

ggsave(
  file.path(results_dir, "GSEA_Hallmark_IL6_JAK_STAT3.png"),
  plot = p_il6_jak,
  width = 7,
  height = 6,
  dpi = 300
)







# 10.3. Hallmark Inflammatory Response


p_inflam <- gseaplot2(
  gsea_hallmark,
  geneSetID = "HALLMARK_INFLAMMATORY_RESPONSE",
  title = "Hallmark Inflammatory Response",
  base_size = 12,
  subplots = c(1, 2, 3))

p_inflam

ggsave(
  file.path(results_dir, "GSEA_Hallmark_Inflammatory_Response.png"),
  plot = p_inflam,
  width = 7,
  height = 6,
  dpi = 300
)






# 10.4. Hallmark Allograft Rejection


p_allograft <- gseaplot2(
  gsea_hallmark,
  geneSetID = "HALLMARK_ALLOGRAFT_REJECTION",
  title = "Hallmark Allograft Rejection",
  base_size = 12,
  subplots = c(1, 2, 3))

p_allograft

ggsave(
  file.path(results_dir, "GSEA_Hallmark_Allograft_Rejection.png"),
  plot = p_allograft,
  width = 7,
  height = 6,
  dpi = 300
)






# 10.5. Hallmark TNFA Signaling via NFKB


p_tnfa_nfkb <- gseaplot2(
  gsea_hallmark,
  geneSetID = "HALLMARK_TNFA_SIGNALING_VIA_NFKB",
  title = "Hallmark TNFA Signaling via NFKB",
  base_size = 12,
  subplots = c(1, 2, 3))

p_tnfa_nfkb

ggsave(
  file.path(results_dir, "GSEA_Hallmark_TNFA_NFKB.png"),
  plot = p_tnfa_nfkb,
  width = 7,
  height = 6,
  dpi = 300
)






# 10.6. Hallmark Apoptosis


p_apoptosis <- gseaplot2(
  gsea_hallmark,
  geneSetID = "HALLMARK_APOPTOSIS",
  title = "Hallmark Apoptosis",
  base_size = 12,
  subplots = c(1, 2, 3))

p_apoptosis

ggsave(
  file.path(results_dir, "GSEA_Hallmark_Apoptosis.png"),
  plot = p_apoptosis,
  width = 7,
  height = 6,
  dpi = 300
)






# 10.7. Hallmark IL2 STAT5 Signaling


p_il2_stat5 <- gseaplot2(
  gsea_hallmark,
  geneSetID = "HALLMARK_IL2_STAT5_SIGNALING",
  title = "Hallmark IL2 STAT5 Signaling",
  base_size = 12,
  subplots = c(1, 2, 3))

p_il2_stat5

ggsave(
  file.path(results_dir, "GSEA_Hallmark_IL2_STAT5.png"),
  plot = p_il2_stat5,
  width = 7,
  height = 6,
  dpi = 300
)






# 10.8. Hallmark Complement


p_complement <- gseaplot2(
  gsea_hallmark,
  geneSetID = "HALLMARK_COMPLEMENT",
  title = "Hallmark Complement",
  base_size = 12,
  subplots = c(1, 2, 3))
  
p_complement

ggsave(
  file.path(results_dir, "GSEA_Hallmark_Complement.png"),
  plot = p_complement,
  width = 7,
  height = 6,
  dpi = 300
)






```


# 11. Viral RPM vs. IFN 

```{r}
#| warning: false






# 11.1. Import data


library(dplyr)
library(ggplot2)
library(tidyr)
library(tibble)
library(msigdbr)

# Import rna norm expr
rna_norm <- read.csv(
  file.path(results_dir, "rna_norm.csv"),
  stringsAsFactors=F)

# Import metadata
metadata_df_with_folds <- read.csv(
  file.path(data_dir, "metadata_df_with_folds.csv"),
  stringsAsFactors=F)

# Import microbe reports
microbe_reports_bgfilter <- read.csv(
  file.path(data_dir, "microbe_reports_bgfilter.csv"),
  stringsAsFactors=F)

# Import protein matrix
protein_mat <- read.csv(
  file.path("C:/Users/User/Documents/UCSF/BREATH2.Prot/data/protein_mat.csv"),
  stringsAsFactors=F)






# 11.2. Select IFN plots


# Ensure same patients are used
microbe_reports_bgfilter <- microbe_reports_bgfilter %>%
  filter(sample_name %in% metadata_df_with_folds$sample_name)

# Filter to viruses only
virus_reports <- microbe_reports_bgfilter %>%
  filter(category == "viruses") %>%
  mutate(
    sample_name = factor(
      sample_name,
      levels = metadata_df_with_folds$sample_name)) %>%
  arrange(sample_name)

# Run by dominant virus
#viral_rpm_df <- virus_reports %>%
  #group_by(sample_name) %>%
  #summarize(
    #viral_rpm = max(nt_rpm, na.rm = TRUE))

# Run by sum viral rpm
viral_rpm_df <- virus_reports %>%
  group_by(sample_name) %>%
  summarize(
    viral_rpm = sum(nt_rpm, na.rm = TRUE))

# Add back all patients (patients with no viral rpm included with 0)
viral_rpm_df <- metadata_df_with_folds %>%
  dplyr::select(sample_name, LRTI_adjudication) %>%
  left_join(viral_rpm_df, by = "sample_name") %>%
  mutate(
    viral_rpm = ifelse(is.na(viral_rpm), 0, viral_rpm)
  )

write.csv(viral_rpm_df,
          file.path(results_dir, "viral_rpm_df.csv"),
          row.names=F)






# 11.2a. Select Gene IFNs


ifn_genes <- c("ISG15", "IFIT2", "IFIT3")

rna_ifn_long <- rna_norm %>%
  filter(gene_symbol %in% ifn_genes) %>%
  pivot_longer(
    cols = -c(gene, gene_symbol),
    names_to = "sample_name",
    values_to = "expr"
  ) %>%
  mutate(
    expr_log2 = log2(expr + 1)
  )

ifn_rna_df <- rna_ifn_long %>%
  left_join(
    viral_rpm_df %>% 
      dplyr::select(sample_name, viral_rpm, LRTI_adjudication),
    by = "sample_name"
  )

# Restrict to Definite LRTI only
ifn_rna_df_definite <- ifn_rna_df %>%
  filter(LRTI_adjudication == "Definite")

write.csv(
  rna_ifn_long,
  file.path(results_dir, "IFN_RNA_normalized_long.csv"),
  row.names=F)






# 11.2b. Select Protein IFNs


ifn_proteins <- c("ISG15", "IFIT2", "IFIT3")

protein_ifn_long <- protein_mat %>%
  rename(patient_id = X) %>%                     # X → patient_id
  mutate(patient_id = as.integer(patient_id)) %>%
  dplyr::select(patient_id, all_of(ifn_proteins)) %>%
  pivot_longer(
    cols = -patient_id,
    names_to = "gene_symbol",
    values_to = "expr_log2"
  ) %>%
  left_join(
    metadata_df_with_folds %>%
      dplyr::select(patient_id, sample_name),
    by = "patient_id"
  ) %>%
  left_join(
    viral_rpm_df,
    by = "sample_name"
  ) %>%
  filter(LRTI_adjudication == "Definite") %>%
  mutate(modality = "Protein")

ifn_rna_df_definite <- ifn_rna_df_definite %>%
  mutate(modality = "RNA")






# 11.2c. Combine RNA/Protein


ifn_combined_df <- bind_rows(
  ifn_rna_df_definite %>%
    dplyr::select(sample_name, gene_symbol, expr_log2, viral_rpm, modality),
  protein_ifn_long %>%
    dplyr::select(sample_name, gene_symbol, expr_log2, viral_rpm, modality)
)






# 11.2c. Viral RPM vs IFN plot


ggplot(
  ifn_combined_df,
  aes(
    x = log10(viral_rpm + 1),
    y = expr_log2,
    color = modality
  )
) +
  geom_point(alpha = 0.7, size = 1.5) +
  geom_smooth(method = "lm", se = FALSE) +
  facet_wrap(~ gene_symbol, scales = "free_y") +
  theme_classic() +
  labs(
    x = "log10 Viral RPM (+1)",
    y = "log2 normalized abundance",
    title = "Viral Load–Dependent IFN Expression",
    subtitle = "RNA and protein shown separately for each IFN"
  )

# Save plot
ggsave(
  filename = file.path(results_dir, "Viral_RPM_vs_IFN_RNA_Protein.png"),
  plot = last_plot(),
  width = 9,
  height = 5,
  dpi = 300
)





# 11.3. Composite IFN score plot


ifn_geneset <- msigdbr(
  species = "Homo sapiens",
  category = "H"
) %>%
  filter(gs_name %in% c(
    "HALLMARK_INTERFERON_ALPHA_RESPONSE",
    "HALLMARK_INTERFERON_GAMMA_RESPONSE"
  )) %>%
  pull(gene_symbol) %>%
  unique()






# 11.3a. Calculate RNA score


hallmark_ifn_genes <- intersect(ifn_geneset, rna_norm$gene_symbol)

# Build long format RNA table for IFN genes
rna_ifn_hallmark_long <- rna_norm %>%
  filter(gene_symbol %in% hallmark_ifn_genes) %>%
  pivot_longer(
    cols = -c(gene, gene_symbol),
    names_to = "sample_name",
    values_to = "expr"
  ) %>%
  mutate(expr_log2 = log2(expr + 1))

# Calculate composite IFN score per sample
ifn_score_df <- rna_ifn_hallmark_long %>%
  group_by(gene_symbol) %>%
  mutate(expr_scaled = scale(expr_log2)) %>%  # scale per gene
  ungroup() %>%
  group_by(sample_name) %>%
  summarize(IFN_score = mean(expr_scaled, na.rm = TRUE))

summary(ifn_score_df$IFN_score)
nrow(ifn_score_df)

# Merge with viral RPM and LRTI adjudication info
ifn_score_plot_df <- ifn_score_df %>%
  left_join(
    viral_rpm_df %>% 
      dplyr::select(sample_name, viral_rpm, LRTI_adjudication),
    by = "sample_name"
  )

# Filter to Definite LRTI cases only
ifn_score_plot_df_definite <- ifn_score_plot_df %>%
  filter(LRTI_adjudication == "Definite")

ifn_score_plot_df_definite <- ifn_score_plot_df_definite %>%
  mutate(modality = "RNA")






# 11.3b. Calculate protein score


protein_ifn_hallmark_long <- protein_mat %>%
  rename(patient_id = X) %>%                  
  mutate(patient_id = as.integer(patient_id)) %>%
  pivot_longer(
    cols = -patient_id,
    names_to = "gene_symbol",
    values_to = "expr_log2"
  ) %>%
  filter(gene_symbol %in% hallmark_ifn_genes) %>%
  left_join(
    metadata_df_with_folds %>%
      dplyr::select(patient_id, sample_name),
    by = "patient_id"
  )

protein_ifn_score_df <- protein_ifn_hallmark_long %>%
  group_by(gene_symbol) %>%
  mutate(expr_scaled = scale(expr_log2)) %>%   # scale per protein
  ungroup() %>%
  group_by(sample_name) %>%
  summarize(IFN_score = mean(expr_scaled, na.rm = TRUE)) %>%
  mutate(modality = "Protein")

ifn_score_combined_df <- bind_rows(
  ifn_score_plot_df_definite %>%
    dplyr::select(sample_name, viral_rpm, IFN_score, modality),
  protein_ifn_score_df %>%
    left_join(
      viral_rpm_df %>%
        dplyr::select(sample_name, viral_rpm, LRTI_adjudication),
      by = "sample_name"
    ) %>%
    filter(LRTI_adjudication == "Definite") %>%
    dplyr::select(sample_name, viral_rpm, IFN_score, modality)
)






# 11.3c. Plot composite score


# ifn_score_combined_df has columns: sample_name, viral_rpm, IFN_score, modality
cor_df <- ifn_score_combined_df %>%
  group_by(modality) %>%
  summarize(
    spearman_r = cor(IFN_score, log10(viral_rpm + 1), method = "spearman"),
    .groups = "drop"
  ) %>%
  mutate(

    # Adjust y position for each modality so they don't overlap
    y_pos = ifelse(modality == "RNA", max(ifn_score_combined_df$IFN_score)*0.95,
                   max(ifn_score_combined_df$IFN_score)*0.85)
  )

ggplot(
  ifn_score_combined_df,
  aes(
    x = log10(viral_rpm + 1),
    y = IFN_score,
    color = modality
  )
) +
  geom_point(alpha = 0.7, size = 1.8) +
  geom_smooth(method = "lm", se = TRUE) +
  theme_classic() +
  labs(
    x = "log10 Viral RPM (+1)",
    y = "Composite IFN score (z-scored)",
    title = "Viral Load vs Composite Interferon Response",
    subtitle = "Hallmark IFNα + IFNγ pathways (RNA and protein)"
  )

  #geom_text(
    #data = cor_df,
    #aes(
      #x = max(log10(ifn_score_combined_df$viral_rpm + 1)), 
      #y = y_pos,
      #label = paste0("Spearman \u03C1 = ", round(spearman_r, 3))
    #),
    #inherit.aes = FALSE,
    #hjust = 1.05,
    #size = 4)

# Save plot
ggsave(
  filename = file.path(results_dir, "Composite_IFN_score_vs_Viral_RPM.png"),
  plot = last_plot(),
  width = 7,
  height = 5,
  dpi = 300
)






```


