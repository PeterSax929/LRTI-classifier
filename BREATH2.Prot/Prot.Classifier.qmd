---
title: "Prot.Classifier"
format: html
toc: true
---

# 1. Import Data

```{r}
#| warning: false






# 1.1. Import metadata and protein matrix


# Set file paths
data_dir <- "C:/Users/User/Documents/UCSF/BREATH2.Prot/data"
results_dir <- "C:/Users/User/Documents/UCSF/BREATH2.Prot/results"

setwd(data_dir)

# Import data from Box
vap_soma_normalized <- read.csv(
  file.path(data_dir, "vap_soma_normalized.csv"), 
  stringsAsFactors=F)

JCI_expanded_metadata <- read.csv(
  file.path(data_dir, "fixed_metadata_10242025.csv"),
  stringsAsFactors=F)



# 1.2. Log2 Transformation


# Log2 Transformation
prot_cols <- grepl("^seq_", names(vap_soma_normalized))

vap_soma_normalized[, prot_cols] <- log2(vap_soma_normalized[, prot_cols])

write.csv(vap_soma_normalized, 
          file.path(data_dir, "vap_soma_normalized_transformed.csv"),
          row.names=F)






# 1.3. Build data frame with all patients


# Include only the 151 patients in both datasets
patients_vector <- intersect(vap_soma_normalized$patient_id, 
                             JCI_expanded_metadata$SubjectID)

Prot.Data <- vap_soma_normalized[vap_soma_normalized$patient_id %in% patients_vector, ]
Meta.Data <- JCI_expanded_metadata[JCI_expanded_metadata$SubjectID %in% patients_vector, ]

# Ensures rows of Meta.Data match those of Prot.Data
Meta.Data <- Meta.Data[match(Prot.Data$patient_id, Meta.Data$SubjectID), ]

# Produces data frame with patients, age_in_years, sex, and LRTI_Adjudication
patient_info_ALL <- data.frame(
  sample_name = Meta.Data$sanitized_name,
  patient_id = Prot.Data$patient_id,
  sex = Meta.Data$sex,
  age_in_years = Meta.Data$age_in_years,
  LRTI_adjudication = Meta.Data$LRTI_adjudication,
  stringsAsFactors=F
)

write.csv(Meta.Data, 
          file.path(data_dir, "meta.data.csv"),
          row.names=F)

write.csv(Prot.Data, 
          file.path(data_dir, "prot.data.csv"),
          row.names=F)

write.csv(patient_info_ALL, 
          file.path(data_dir, "patient_info_ALL.csv"),
          row.names=F)






# 1.4. Build protein matrix for all patients


# Isolating Protein Matrix (Columns 211:7806 include the 7596 proteins)
protein_mat_PROBEID <- as.matrix(Prot.Data[, prot_cols])

# Remove "seq_"
colnames(protein_mat_PROBEID) <- sub("^seq_", "", colnames(protein_mat_PROBEID))

# Replace underscores with hyphens
colnames(protein_mat_PROBEID) <- gsub("_", "-", colnames(protein_mat_PROBEID))

# Sets rownames to patient_id 
rownames(protein_mat_PROBEID) <- Prot.Data$patient_id

# Write csv
write.csv(protein_mat_PROBEID, 
          file.path(data_dir, "protein_mat_PROBEID.csv"), 
          row.names=T)






# 1.5. Safety check


sum(duplicated(Meta.Data$SubjectID)) # Should be 0

length(patients_vector) # Should be 151

all(rownames(protein_mat_PROBEID) == patient_info_ALL$patient_id) # Should be TRUE






```


# 2. Protein Lookup Table

```{r}
#| warning: false






# 2.1. Prepare Seq ids


library(dplyr)
library(SomaScan.db)
library(SomaDataIO)
library(AnnotationDbi)  
library(tibble)

protein_mat_PROBEID <- read.csv(
  file.path(data_dir, "protein_mat_PROBEID.csv"), 
  stringsAsFactors=F, check.names=F)

# Extracts all PROBEIDs in protein_mat_ALL
seq_ids <- colnames(protein_mat_PROBEID)






# 2.2. Build protein lookup table


# Build table
protein_lookup_table_ALL <- SomaScan.db::select(
  SomaScan.db,
  keys = seq_ids,
  keytype = "PROBEID",
  columns = c("PROBEID", "SYMBOL", "GENENAME", "UNIPROT")
)

#Remove duplicates
protein_lookup_table_ALL <- protein_lookup_table_ALL %>% distinct(PROBEID, .keep_all=T)






# 2.2a. Collect unmapped probes


# Removes unannotated PROBEIDs
protein_lookup_table_ALL <- protein_lookup_table_ALL %>%
  filter(!is.na(SYMBOL)) %>%
  arrange(SYMBOL)

# All valid PROBEIDs in the package
valid_ids <- keys(SomaScan.db, keytype = "PROBEID")

# Find unmapped probes
unmapped_probes <- setdiff(seq_ids, valid_ids)

# Write csv
write.csv(data.frame(PROBEID = unmapped_probes), 
          file.path(data_dir, "unmapped_probes.csv"), 
          row.names=F)






# 2.2b. Take mean expression for PROBEIDs


# Keep only annotated probes
protein_mat_PROBEID <- protein_mat_PROBEID[, colnames(protein_mat_PROBEID) %in% protein_lookup_table_ALL$PROBEID]

# Reorder lookup table to match the columns in protein_mat_ALL
protein_lookup_table_ALL <- protein_lookup_table_ALL[match(colnames(protein_mat_PROBEID), protein_lookup_table_ALL$PROBEID), ]

# Confirm alignment
stopifnot(all(colnames(protein_mat_PROBEID) == protein_lookup_table_ALL$PROBEID))

# Collapse duplicate probes (mean expression per SYMBOL)
protein_mat_PROBEID_t <- t(protein_mat_PROBEID) %>%
  as.data.frame() %>%
  mutate(SYMBOL = protein_lookup_table_ALL$SYMBOL) %>%
  group_by(SYMBOL) %>%
  summarise(across(everything(), mean, na.rm=T)) %>%
  as.data.frame()

# Restore to original shape
rownames_tmp <- protein_mat_PROBEID_t$SYMBOL






# 2.2c. Align tables


# Define protein_mat_ALL
protein_mat_ALL <- as.data.frame(t(protein_mat_PROBEID_t[, -1]))
colnames(protein_mat_ALL) <- rownames_tmp
rownames(protein_mat_ALL) <- patients_vector


# Remove duplicate SYMBOLs in lookup table to match collapsed matrix
protein_lookup_table <- protein_lookup_table_ALL %>%
  filter(SYMBOL %in% colnames(protein_mat_ALL)) %>%
  distinct(SYMBOL, .keep_all=T)

# Match lookup table order to protein_mat_ALL column order
protein_lookup_table <- protein_lookup_table[match(colnames(protein_mat_ALL),
                                                   protein_lookup_table$SYMBOL), ]

# Write csvs
write.csv(protein_lookup_table, 
          file.path(data_dir, "protein_lookup_table.csv"),
          row.names=F)

write.csv(protein_mat_ALL, 
          file.path(data_dir, "protein_mat_ALL.csv"), 
          row.names=T)






# 2.3. Safety Check


length(unmapped_probes)

nrow(protein_lookup_table) # Should be 6346

# Check for duplicate symbols 
any(duplicated(colnames(protein_mat_ALL)))  # Should return FALSE

# Confirm lengths match
length(colnames(protein_mat_ALL))  # Should be 6346
length(protein_lookup_table$SYMBOL)  # SHould be 6346

# How many symbols overlap
sum(colnames(protein_mat_ALL) %in% protein_lookup_table$SYMBOL)  # Should be 6346






```


# 3. Patient Info Table

```{r}
#| warning: false






# 3.1. Subset both datasets to Definite/No Evidence


# Read csvs
protein_lookup_table <- read.csv( 
          file.path(data_dir, "protein_lookup_table.csv"),
          stringsAsFactors=F)

protein_mat_ALL <- read.csv( 
          file.path(data_dir, "protein_mat_ALL.csv"), 
          stringsAsFactors=F, row.names=1)

# Include only Definite and No Evidence patients
patient_info <- patient_info_ALL[patient_info_ALL$LRTI_adjudication %in% 
                                     c("Definite", "No Evidence"), ]

# Includes only the protein matrix for Definite and No Evidence patients
protein_mat <- protein_mat_ALL[match(patient_info$patient_id, 
                                       rownames(protein_mat_ALL)), ]

# Save outputs
write.csv(patient_info, 
          file.path(data_dir, "patient_info.csv"),
          row.names=F)

write.csv(protein_mat,
          file.path(data_dir, "protein_mat.csv"),
          row.names=T)






# 3.2. Define Workflow Parameters


# Define parameters
Definite <- table(patient_info$LRTI_adjudication)["Definite"]
No_Evidence <- table(patient_info$LRTI_adjudication)["No Evidence"]
npatients <- nrow(patient_info)
nproteins <- ncol(protein_mat)
nfolds <- 5
ntrees <- 10000

# Store parameters as data frame
Parameters <- data.frame(c(npatients, Definite, No_Evidence, nproteins, nfolds, ntrees))
row.names(Parameters) = c("Patients", "Definite", "No Evidence", "Proteins", "Folds", "RF Trees")
colnames(Parameters) = "Count"

# Write csv
write.csv(Parameters, 
          file.path(data_dir, "parameters.csv"),
          row.names=T)

print(Parameters)






# 3.3. Safety Check


# Ensures that protein_mat rownames match patient_id column in patient_info
all(rownames(protein_mat) == patient_info$patient_id)  # Should return TRUE

any(is.na(match(patient_info$patient_id, 
                rownames(protein_mat_ALL))))  # Should return FALSE

# Ensures that protein_mat rownames match patient_id column in patient_info
all(rownames(protein_mat) == patient_info$patient_id)  # Should return TRUE






```

  
# 4. Fold Assignments

```{r}
#| warning: false






# 4.1. Import patient info


library(dplyr)
library(rsample)
library(magrittr)

# Read csvs
patient_info <- read.csv(
  file.path(data_dir, "patient_info.csv"), 
  stringsAsFactors=F)

Parameters <- read.csv(
  file.path(data_dir, "parameters.csv"),
  stringsAsFactors=F, row.names=1)

# Define number of folds
nfolds <- as.numeric(Parameters["Folds", "Count"])

# Define number of No Evidence patients
No_Evidence <- as.numeric(Parameters["No Evidence", "Count"])

# Minimum required per fold
min_NE_per_fold <- floor(No_Evidence / nfolds)







# 4.2. Fold Assignment Using rsample


# Retry until constraints satisfied
folds_ok <- FALSE

# Set seed
set.seed(8634782)

# While loop
while (!folds_ok) {

  # Stratified vfold_cv using rsample
  vfold_obj <- vfold_cv(
    data = patient_info,
    v = nfolds,
    strata = "LRTI_adjudication"
  )

  # Create a data frame that maps each row to a fold
  patient_info_with_folds <- patient_info %>%
    mutate(fold = NA_integer_)

  # Fill in fold assignments
  for (i in seq_len(nfolds)) {
    fold_indices <- vfold_obj$splits[[i]]$in_id
    val_indices <- setdiff(seq_len(nrow(patient_info)), fold_indices)
    patient_info_with_folds$fold[val_indices] <- i
  }

  # Check how many No Evidence cases per fold
  counts <- table(
    patient_info_with_folds$fold,
    patient_info_with_folds$LRTI_adjudication
  )

  if (all(counts[, "No Evidence"] >= min_NE_per_fold)) {
    folds_ok <- TRUE
  }
}

# Save output
write.csv(
  patient_info_with_folds,
  file.path(data_dir, "patient_info_with_folds.csv"),
  row.names=F)






# 4.3. Safety Check


print(counts)

print(min_NE_per_fold)






```


# 5. Lasso CV

```{r}
#| warning: false






# 5.1. Ready data for LASSO Workflow


library(dplyr)
library(magrittr)
library(glmnet)
library(tibble)
library(ggplot2)

set.seed(8634782)

# Import data
patient_info_with_folds <- read.csv(
  file.path(data_dir, "patient_info_with_folds.csv"),
  stringsAsFactors=F)

protein_mat <- read.csv(
  file.path(data_dir, "protein_mat.csv"),
  stringsAsFactors=F, row.names=1, check.names=F)

protein_lookup_table <- read.csv(
  file.path(data_dir, "protein_lookup_table.csv"),
  stringsAsFactors=F)

Parameters <- read.csv(
  file.path(data_dir, "parameters.csv"),
  stringsAsFactors=F, row.names=1)

# Define nfolds
nfolds <- as.numeric(Parameters["Folds", "Count"])

# Prepare inputs for LASSO
X <- as.matrix(protein_mat)  
y <- patient_info_with_folds$LRTI_adjudication == "Definite"






# 5.2. LASSO Workflow


# Function for a single outer CV fold
lasso_cv_outer_fold <- function(test_fold) {
  
  train <- patient_info_with_folds$fold != test_fold
  
 # Fit full lambda path
fit <- glmnet::glmnet(
  X[train, ], y[train],
  family = "binomial",
  standardize = TRUE
)

# Count nonzero coefficients at each lambda
nz <- apply(fit$beta, 2, function(b) sum(b != 0))






# 5.2a. Select 3 Proteins (OPTION A)


# Identify lambda that selects exactly 3 proteins
#if (any(nz == 3)) {
  # Choose the largest lambda with exactly 3 
  #lambda_k3 <- fit$lambda[which(nz == 3)[1]]
#} else {
  # Choose lambda with closest >3, then trim to top3
  #idx <- which.min(abs(nz - 3))
  #lambda_k3 <- fit$lambda[idx]
#}

# Predictions at lambda_k3
#preds <- predict(fit, X[!train, ], type = "response", s = lambda_k3)[, 1] %>%
  #data.frame(pred = .) %>%
  #tibble::rownames_to_column("sample_name")

# Extract coefficients at lambda_k3
#coefs_vec <- coef(fit, s = lambda_k3)[-1, 1]  # remove intercept

# Keep nonzero 
#nonzero <- coefs_vec[coefs_vec != 0]

#if (length(nonzero) > 3) {
  #top3 <- sort(abs(nonzero), decreasing = TRUE)[1:3]
  #nonzero <- nonzero[names(top3)]
#}






# 5.2b. Select 1 Protein (OPTION B)


# Identify lambda that selects exactly 1 protein
#if (any(nz == 1)) {
  # Choose the largest lambda with exactly 1
  #lambda_k1 <- fit$lambda[which(nz == 1)[1]]
#} else {
  # Choose lambda with closest >1, then trim to top1
  #idx <- which.min(abs(nz - 1))
  #lambda_k1 <- fit$lambda[idx]
#}

# Predictions at lambda_k1
#preds <- predict(fit, X[!train, ], type = "response", s = lambda_k1)[, 1] %>%
  #data.frame(pred = .) %>%
  #tibble::rownames_to_column("sample_name")

# Extract coefficients at lambda_k1
#coefs_vec <- coef(fit, s = lambda_k1)[-1, 1]  # remove intercept

# Keep nonzero 
#nonzero <- coefs_vec[coefs_vec != 0]

#if (length(nonzero) == 0) {
  # Find index of current lambda
  #lam_idx <- which(fit$lambda == lambda_k1)
  # Move to next less-penalized lambda
  #if (lam_idx < length(fit$lambda)) {
    #next_lambda <- fit$lambda[lam_idx + 1]
    #coefs_next <- coef(fit, s = next_lambda)[-1, 1]
    # Select strongest coefficient at next lambda
    #best_name <- names(coefs_next)[which.max(abs(coefs_next))]
    #nonzero <- coefs_next[best_name]
  #} else {
    # Extremely rare: lambda_k1 is already smallest
    #nonzero <- numeric(0)
  #}
#}

#if (length(nonzero) > 1) {
  #top1 <- sort(abs(nonzero), decreasing = TRUE)[1]
  #nonzero <- nonzero[names(top1)]
#}






# 5.2c. Select lambda based on LASSO CV (OPTION C)


# Perform cross validated LASSO to pick optimal lambda
cv_fit <- cv.glmnet(
  X[train, ], y[train],
  family = "binomial",
  standardize = TRUE,
  nfolds = nfolds
)

# Predictions on test fold
preds <- predict(fit, X[!train, ], type = "response",
  s = cv_fit$lambda.1se)[, 1] %>%
  data.frame(pred = .) %>%
  tibble::rownames_to_column("sample_name")

# Extract coefficients at selected lambda
coefs_vec <- coef(fit, s = cv_fit$lambda.1se)[-1, 1]  # remove intercept

# Keep nonzero coefficients only
 nonzero <- coefs_vec[coefs_vec != 0]






# 5.2d. Build data frame


# Build dataframe
nonzero <- data.frame(
  protein = names(nonzero),
  coef = as.numeric(nonzero),
  fold = test_fold
)

  list(pred = preds, mod = fit, coef = nonzero) 
}






# 5.3. Run LASSO on all folds


# Run LASSO across all folds
lasso_results <- lapply(
  1:max(patient_info_with_folds$fold), 
  lasso_cv_outer_fold)

# Combine predictions and coefficients
lasso_preds <- lasso_results %>%
  lapply(function(x) x$pred) %>%
  bind_rows()

lasso_fold_coefs <- lasso_results %>%
  lapply(function(x) x$coef) %>%
  bind_rows()

# Merge SYMBOL-based annotations directly
lasso_fold_coefs <- merge(
  lasso_fold_coefs,
  protein_lookup_table,
  by.x = "protein",
  by.y = "SYMBOL",
  all.x = TRUE
)

# Save outputs
write.csv(lasso_preds, 
          file.path(results_dir, "lasso_preds.csv"), 
          row.names=F)

write.csv(lasso_fold_coefs,
          file.path(results_dir, "lasso_fold_coefs.csv"),
          row.names=F)






# 5.4. Safety Check


# Summary
print(table(lasso_fold_coefs$protein))

all(lasso_fold_coefs$protein %in% 
      protein_lookup_table$SYMBOL)  # Should return TRUE

nrow(lasso_fold_coefs) 

all(rownames(X) == patient_info_with_folds$patient_id) # Should return TRUE






# 5.5 Bar Graph


prot_freq <- table(lasso_fold_coefs$protein)

prot_df <- as.data.frame(prot_freq)

colnames(prot_df) = c("protein", "fold_freq")






# 5.5a. Protein frequency plot


ggplot(
  prot_df %>% filter(prot_freq > 1),
  aes(
    x = reorder(protein, fold_freq),
    y = fold_freq
  )
) +
  geom_col(fill = "steelblue", width = 0.7) +
  scale_y_continuous(breaks = 1:5) +
  labs(
    title = "Proteins Selected Across >1 Fold",
    x = NULL,
    y = "Number of folds selected"
  ) +
  theme_minimal(base_size = 14)






# 5.5b. Plot top 10 |coefs|


top10coefs <- lasso_fold_coefs %>% 
    slice_max(order_by = abs(lasso_fold_coefs$coef), n=10)

ggplot(
  top10coefs,
  aes(
    x = coef,
    y = interaction(protein, fold, sep = " | ")
  )
) +
  geom_col(fill = "#d95f02", width = 0.7) +
  
  geom_text(
    aes(label = paste0("Fold ", fold)),
    position = position_stack(vjust = 0.5),
    color = "white",
    size = 4) +
  
  geom_text(
  aes(label = round(coef, 3)),
  hjust = ifelse(top10coefs$coef > 0, -0.1, 1.1),
  size = 4
) +
  
  scale_x_continuous(
    limits = c(-1.0, 1.5),
    breaks = seq(-1.5, 1.5, by = 0.5)
  ) +
  scale_y_discrete(limits = sort) +
  labs(
    title = "Top 10 Proteins by |coef|",
    x = "Coefficient",
    y = NULL
  ) +
  theme_minimal(base_size = 14)






```


# 6. Random Forest

```{r}
#| warning: false






# 6.1. Import Data for RF


library(dplyr)
library(magrittr)
library(randomForest)
library(tibble)

set.seed(8634782)

# Import data
patient_info_with_folds <- read.csv(
  file.path(data_dir, "patient_info_with_folds.csv"),
  stringsAsFactors=F)

protein_mat <- read.csv(
  file.path(data_dir, "protein_mat.csv"), 
  stringsAsFactors=F, row.names=1, check.names=F)

Parameters <- read.csv(
  file.path(data_dir, "parameters.csv"),
  stringsAsFactors=F, row.names=1)

# Define ntrees 
ntrees <- as.numeric(Parameters["RF Trees", "Count"])

# Convert patient_id to character
patient_info_with_folds$patient_id <- as.character(patient_info_with_folds$patient_id)

# Import selected proteins
lasso_fold_coefs <- read.csv(
  file.path(results_dir, "lasso_fold_coefs.csv"), 
  stringsAsFactors=F)

selected_lasso_coefs <- lasso_fold_coefs






# 6.2. RF function


# Outcome variable
y <- as.factor(patient_info_with_folds$LRTI_adjudication)  

# Function to run Random Forest for one outer CV fold
lassoRF_cv_outer_fold <- function(test_fold) {
  
  # Extract proteins selected by LASSO for this fold
  keep <- selected_lasso_coefs %>%
            filter(fold == test_fold) %>%
            .$protein
  
  # Subset protein matrix to selected proteins; rows = samples, columns = selected proteins
  X <- protein_mat[, keep, drop = FALSE]  
  
  # Boolean for training samples
  train <- patient_info_with_folds$fold != test_fold
  
  # Fit Random Forest (10000 Trees)
  rf <- randomForest(X[train, , drop = FALSE], y[train], ntree = ntrees)
  
  # Predictions on test fold
  preds <- predict(rf, newdata = X[!train, , drop = FALSE], type = "prob")[, "Definite"]
  
  list(test_fold = test_fold, mod = rf, pred = preds)
}

# Run RF across all folds
cv_list <- lapply(1:max(patient_info_with_folds$fold), lassoRF_cv_outer_fold)

# Ensure correct format
patient_info_with_folds <- as.data.frame(patient_info_with_folds)






# 6.3. Collect preds


# Collect out-of-fold predictions for all samples
rf_preds <- cv_list %>%
  lapply(function(x) {
    data.frame(
      patient_id = rownames(protein_mat)[patient_info_with_folds$fold == x$test_fold],
      pred = x$pred
    )
  }) %>%
  bind_rows() %>%
  dplyr::left_join(dplyr::select(patient_info_with_folds, patient_id, LRTI_adjudication), 
            by = "patient_id") %>%
  dplyr::relocate(LRTI_adjudication, .after = patient_id)

# Save RF predictions
write.csv(rf_preds, 
          file.path(results_dir, "lassoRF_preds.csv"),
          row.names=F)






# 6.4. Collect votes


# Collect RF votes (training set OOB probabilities)
rf_votes <- cv_list %>%
  lapply(function(x) {
    as.data.frame(x$mod$votes) %>%
      tibble::rownames_to_column("patient_id") %>%
      mutate(test_fold = x$test_fold) %>%
      rename(pred = Definite) %>%
      dplyr::select(test_fold, patient_id, pred)
  }) %>%
  bind_rows() %>%
  dplyr::left_join(dplyr::select(patient_info_with_folds, patient_id, LRTI_adjudication), 
            by = "patient_id") %>%
  dplyr::relocate(LRTI_adjudication, .after = patient_id)

# Save votes
write.csv(rf_votes, 
          file.path(results_dir, "lassoRF_votes.csv"),
          row.names=F)






# 6.5. Safety Check


# Summary
table(selected_lasso_coefs$protein)

all(selected_lasso_coefs$protein %in% colnames(protein_mat)) # Should return TRUE

nrow(rf_preds) == nrow(patient_info_with_folds) # Should return TRUE






```


# 7. ROC Curve

```{r}
#| warning: false






# 7.1. Import metadata & preds


library(dplyr)
library(magrittr)
library(pROC)

# Import fold assignments
patient_info_with_folds <- read.csv(
  file.path(data_dir, "patient_info_with_folds.csv"),
  stringsAsFactors=F)

# Import out-of-fold predictions
lassoRF_preds <- read.csv(
  file.path(results_dir, "lassoRF_preds.csv"),
  stringsAsFactors=F)

# Ensure consistent factor levels
lassoRF_preds$LRTI_adjudication <- factor(
  lassoRF_preds$LRTI_adjudication,
  levels = c("No Evidence", "Definite")
)

# Merge once so we reuse this everywhere
merged_preds <- lassoRF_preds %>%
  dplyr::inner_join(
    patient_info_with_folds %>% dplyr::select(patient_id, fold),
    by = "patient_id"
  )






# 7.2. Per-fold AUC


output_auc_roc <- function(preds_df, output_suffix) {

  # Compute per-fold AUC
  auc_df <- preds_df %>%
    group_by(fold) %>%
    summarize({
  roc_obj <- pROC::roc(
    response  = factor(LRTI_adjudication, levels = c("No Evidence", "Definite")),
    predictor = pred,
    direction = "<"
  )
  ci_vals <- pROC::ci.auc(roc_obj, conf.level = 0.95)
  tibble(
    auc = as.numeric(roc_obj$auc),
    auc_lower = ci_vals[1],
    auc_upper = ci_vals[3]
  )
}, .groups = "drop")


  # Determine number of folds
  max_fold <- max(auc_df$fold)

  # Create ROC PDF (all folds overlayed)
  pdf(file.path(results_dir, paste0("ROC_", output_suffix, ".pdf")))

  for (i in 1:max_fold) {
    fold_data <- preds_df %>% filter(fold == i)

    roc_obj <- pROC::roc(
      response  = factor(fold_data$LRTI_adjudication, levels = c("No Evidence", "Definite")),
      predictor = fold_data$pred,
      direction = "<"
    )

    plot(roc_obj, add = (i != 1), col = i)
  }

  dev.off()

  # Save per-fold AUC CSV at the very end
  write.csv(
    auc_df,
    file.path(results_dir, paste0("cv_auc_", output_suffix, ".csv")),
    row.names=F)

  return(auc_df)
}






# 7.3. Plot Graph


# Run AUC computation and PDF creation
auc_lassoRF <- output_auc_roc(merged_preds, "lassoRF")

max_fold <- max(auc_lassoRF$fold)

# Open empty plot for overlay with top-left orientation
plot(0, 0, type = "n",
     xlim = c(1, 0), ylim = c(0, 1),
     xlab = "Specificity", ylab = "Sensitivity",
     main = "ROC Curves by Fold")

# Add diagonal reference
lines(x = c(1, 0), y = c(0, 1), lty = 2, col = "gray")

for (i in 1:max_fold) {
  fold_data <- merged_preds %>% filter(fold == i)

  roc_obj <- pROC::roc(
    response  = factor(fold_data$LRTI_adjudication, levels = c("No Evidence", "Definite")),
    predictor = fold_data$pred,
    direction = "<"
  )

  # Plot specificity directly: axis direction flips via xlim
  lines(roc_obj$specificities, roc_obj$sensitivities, col = i, lwd = 2)
}

legend("bottomright", legend = paste("Fold", 1:max_fold), col = 1:max_fold, lwd = 2)






# 7.4. Summaries


# DeLong 95% CI for overall ROC
ci_auc <- pROC::ci.auc(
  pROC::roc(
    response = factor(merged_preds$LRTI_adjudication, levels = c("No Evidence", "Definite")),
    predictor = merged_preds$pred,
    direction = "<"
  ),
  conf.level = 0.95
)

message("Lower AUC: ", round(ci_auc[1], 3))
message("Mean AUC: ", round(as.numeric(ci_auc[2]), 3))
message("Upper AUC: ", round(ci_auc[3], 3))

print(auc_lassoRF)






```


#8. Differential Abundance

```{r}
#| warning: false






# 8.1. Import data


library(limma)
library(ggplot2)
library(ggrepel)
library(dplyr)
library(tibble)

# Import csvs
metadata_df_with_folds <- read.csv(
  file.path(data_dir, "patient_info_with_folds.csv"),
  stringsAsFactors=F)

protein_mat <- read.csv(
  file.path(data_dir, "protein_mat.csv"),
  stringsAsFactors=F, row.names=1)

# Ensure metadata rows are aligned to protein_mat (safety check)
metadata_df_with_folds <- metadata_df_with_folds %>%
  filter(patient_id %in% rownames(protein_mat)) %>%
  column_to_rownames("patient_id")

# Subset protein matrix to matched ordering (safety check)
protein_mat <- protein_mat[rownames(metadata_df_with_folds), ]






# 8.2. Limma DA


# Create design matrix (Definite vs No Evidence)
metadata_df_with_folds$LRTI_adjudication <- factor(
  metadata_df_with_folds$LRTI_adjudication,
  levels = c("No Evidence", "Definite"))

design <- model.matrix(~ LRTI_adjudication, data = metadata_df_with_folds)

# Fit linear model
fit <- lmFit(t(protein_mat), design)   # transpose so features = rows

fit <- eBayes(fit)

# Extract results
res <- topTable(
  fit,
  coef = "LRTI_adjudicationDefinite",
  number = Inf,
  sort.by = "P")

# Convert to dataframe with gene column
res_df <- res %>%
  rownames_to_column("gene") %>%
  mutate(
    padj = adj.P.Val,
    log2FoldChange = logFC,          
    negLog10P = -log10(P.Value + 1e-300))






# 8.3. Volcano Plot


# 8.3a. Plot content


# Direction categories 
res_df <- res_df %>%
  mutate(
    direction = case_when(
      log2FoldChange > 1  ~ "Definite",
      log2FoldChange < -1 ~ "NoEvidence",
      abs(log2FoldChange) <= 1 ~ "Neutral"),
    
    sig = padj < 0.05 & abs(log2FoldChange) >= 1)

# Top 10 significant proteins per direction
top_definite <- res_df %>% 
  filter(direction == "Definite") %>%
  arrange(padj) %>%
  head(10)

top_noEvidence <- res_df %>% 
  filter(direction == "NoEvidence") %>%
  arrange(padj) %>%
  head(10)

top_labels <- bind_rows(top_definite, top_noEvidence)






# 8.3b. ggplot


# Volcano Plot
ggplot(res_df, aes(x = log2FoldChange, y = negLog10P)) +
  geom_point(aes(color = direction), alpha = 0.6) +
  scale_color_manual(values = c(
    "Definite" = "blue",
    "NoEvidence" = "red",
    "Neutral" = "grey70"
  )) +
  geom_vline(xintercept = c(-1, 1), linetype = "dashed") +
  geom_hline(yintercept = -log10(0.05), linetype = "dashed") +
  theme_minimal() +
  labs(x = "log2 Fold Change",
       y = "-log10(p-value)",
       title = "Volcano plot - Proteomics Differential Abundance") +
  geom_text_repel(
    data = top_labels,
    aes(label = gene),
    size = 3,
    max.overlaps = 30
  )

# Save results
write.csv(res_df,
          file.path(results_dir, "DA_results_proteomics.csv"),
          row.names = FALSE)

ggsave(file.path(results_dir, "volcano_proteome.png"),
       width = 8, height = 6)






```


# 9. Pathway Analysis

```{r}
#| warning: false






# 9.1. Import data


library(clusterProfiler)
library(msigdbr)
library(org.Hs.eg.db)
library(dplyr)
library(ggplot2)
library(enrichplot)
library(stringr)

res_df <- read.csv(
  file.path(results_dir, "DA_results_proteomics.csv"),
  stringsAsFactors=F)






# 9.2. Ranked Proteins List


# Use protein IDs and log2FC
protein_ranks <- res_df$log2FoldChange
names(protein_ranks) <- res_df$gene

# Sort decreasing 
protein_ranks <- sort(protein_ranks, decreasing = TRUE)

# protein_ranks is a named numeric vector
protein_ranks_df <- data.frame(
  gene = names(protein_ranks),
  log2FC = as.numeric(protein_ranks)
)

write.csv(
  protein_ranks_df,
  file.path(results_dir, "protein_ranks_for_RNA_GSEA.csv"),
  row.names = FALSE
)






# 9.3. Hallmark GSEA


hallmark_sets <- msigdbr(
  species  = "Homo sapiens",
  category = "H"
) %>%
  dplyr::select(gs_name, gene_symbol)

gsea_hallmark_prot <- GSEA(
  geneList  = protein_ranks,
  TERM2GENE = hallmark_sets,
  pvalueCutoff = 0.05,
  eps = 0,
  verbose = FALSE
)

hallmark_df_prot <- as.data.frame(gsea_hallmark_prot)

write.csv(
  hallmark_df_prot,
  file.path(results_dir, "GSEA_Hallmark_proteome.csv"),
  row.names=F
)






# 9.4. Reactome GSEA


reactome_sets <- msigdbr(
  species     = "Homo sapiens",
  category    = "C2",
  subcategory = "CP:REACTOME"
) %>%
  dplyr::select(gs_name, gene_symbol)

gsea_reactome_prot <- GSEA(
  geneList  = protein_ranks,
  TERM2GENE = reactome_sets,
  pvalueCutoff = 0.05,
  verbose = FALSE
)

reactome_df_prot <- as.data.frame(gsea_reactome_prot)

write.csv(
  reactome_df_prot,
  file.path(results_dir, "GSEA_Reactome_proteome.csv"),
  row.names = FALSE
)






# 9.5. Hallmark Pathway Plots


# View top Hallmark pathways by NES
gsea_hallmark_prot@result %>%
  filter(p.adjust < 0.05) %>%
  arrange(desc(abs(NES))) %>%
  dplyr::select(ID, Description, NES, p.adjust) %>%
  head(10)

# IFNγ
p_ifng_prot <- gseaplot2(
  gsea_hallmark_prot,
  geneSetID = "HALLMARK_INTERFERON_GAMMA_RESPONSE",
  title = "Protein Hallmark IFNγ Response",
  base_size = 12,
  subplots = c(1,2,3))

ggsave(
  file.path(results_dir, "GSEA_IFNG_protein.png"),
  p_ifng_prot,
  width = 7,
  height = 6,
  dpi = 300
)

# IFNα
p_ifna_prot <- gseaplot2(
  gsea_hallmark_prot,
  geneSetID = "HALLMARK_INTERFERON_ALPHA_RESPONSE",
  title = "Protein Hallmark IFNα Response",
  base_size = 12,
  subplots = c(1,2,3))

# Print plots
p_ifng_prot
p_ifna_prot

# Save plots
ggsave(
  file.path(results_dir, "GSEA_IFNG_protein.png"),
  p_ifng_prot,
  width = 7,
  height = 6,
  dpi = 300
)

ggsave(
  file.path(results_dir, "GSEA_IFNA_protein.png"),
  p_ifna_prot,
  width = 7,
  height = 6,
  dpi = 300
)






# 9.6. Reactome Pathway Plot


# View top Reactome pathways
gsea_reactome_prot@result %>%
  filter(p.adjust < 0.05) %>%
  arrange(desc(abs(NES))) %>%
  dplyr::select(ID, Description, NES, p.adjust) %>%
  head(10)

p_reactome_digest_prot <- gseaplot2(
  gsea_reactome_prot,
  geneSetID = "REACTOME_DIGESTION",
  title = "Protein Reactome: Digestion",
  base_size = 12,
  subplots = c(1, 2, 3))

# Print plot
p_reactome_digest_prot

# Save plot
ggsave(
  filename = file.path(results_dir, "GSEA_Reactome_Digestion_protein.png"),
  plot = p_reactome_digest_prot,
  width = 7,
  height = 6,
  dpi = 300
)






# 9.7. Hallmark GSEA summary dot plot


# Prepare Hallmark plot data
hallmark_plot_prot_df <- gsea_hallmark_prot@result %>%
  filter(p.adjust < 0.05) %>%
  mutate(
    neglogPadj = -log10(p.adjust),
    Direction = ifelse(NES > 0, "Up", "Down"),
    # replace underscores and wrap long names
    Description = str_wrap(gsub("_", " ", Description), width = 40),
    Description = factor(Description, levels = Description[order(NES)])
  )

# Plot
p_hallmark_all_prot <- ggplot(
  hallmark_plot_prot_df,
  aes(y = Description, x = NES)
) +
  # Center line (NES = 0)
  geom_vline(xintercept = 0, linewidth = 0.8, color = "black") +
  # Stems
  geom_segment(aes(x = 0, xend = NES, yend = Description), linewidth = 0.7, color = "grey60") +
  # Points colored by direction
  geom_point(aes(color = Direction), size = 4) +
  scale_color_manual(values = c("Up" = "red3", "Down" = "blue3"), name = "Enrichment direction") +
  # Styling
  theme_classic(base_size = 12) +
  theme(
    axis.text.y = element_text(size = 8),
    plot.title.position = "plot",
    plot.title = element_text(hjust = 0.5, face = "bold"),
    plot.subtitle = element_text(hjust = 0.5),
    plot.margin = ggplot2::margin(t = 10, r = 40, b = 10, l = 10)
  ) +
  labs(
    title = "Hallmark Pathway Enrichment (Protein GSEA)",
    subtitle = "All significant Hallmark pathways",
    x = "Normalized Enrichment Score (NES)",
    y = NULL
  ) +
  xlim(-5, 5)

# Show plot
p_hallmark_all_prot

# Save plot
ggsave(
  filename = file.path(results_dir, "GSEA_Hallmark_all_protein.png"),
  plot = p_hallmark_all_prot,
  width = 8,
  height = 8,  
  dpi = 300
)






# 9.8. Reactome GSEA summary dot plot


# Prepare Reactome plot data
reactome_plot_prot_df <- gsea_reactome_prot@result %>%
  filter(p.adjust < 0.05) %>%
  mutate(
    neglogPadj = -log10(p.adjust),
    Direction = ifelse(NES > 0, "Up", "Down")
  )

# Top 10 Up
reactome_top_up_prot <- reactome_plot_prot_df %>%
  filter(NES > 0) %>%
  arrange(desc(NES)) %>%
  slice_head(n = 10)

# Top 10 Down
reactome_top_down_prot <- reactome_plot_prot_df %>%
  filter(NES < 0) %>%
  arrange(NES) %>%
  slice_head(n = 10)

reactome_top20_prot <- bind_rows(reactome_top_up_prot, reactome_top_down_prot) %>%
  mutate(
    Description = gsub("_", " ", Description),
    Description = str_wrap(Description, width = 40),
    Description = factor(Description, levels = Description[order(NES)])
  )

# Plot Reactome protein top 20
p_reactome_top20_prot <- ggplot(
  reactome_top20_prot,
  aes(y = Description, x = NES)
) +
  geom_vline(xintercept = 0, linewidth = 0.8, color = "black") +
  geom_segment(aes(x = 0, xend = NES, yend = Description), linewidth = 0.7, color = "grey60") +
  geom_point(aes(color = Direction), size = 4) +
  scale_color_manual(values = c("Up" = "red3", "Down" = "blue3"), name = "Enrichment direction") +
  theme_classic(base_size = 12) +
  theme(
    axis.text.y = element_text(size = 7),
    plot.title.position = "plot",
    plot.title = element_text(hjust = 0.5, face = "bold"),
    plot.subtitle = element_text(hjust = 0.5),
    plot.margin = ggplot2::margin(t = 10, r = 40, b = 10, l = 10)
  ) +
  labs(
    title = "Reactome Pathway Enrichment (Protein GSEA)",
    subtitle = "Top up and top down pathways",
    x = "Normalized Enrichment Score (NES)",
    y = NULL
  ) +
  xlim(-5, 5)

# Print plot
p_reactome_top20_prot

# Save plot
ggsave(
  filename = file.path(results_dir, "GSEA_Reactome_top20_protein.png"),
  plot = p_reactome_top20_prot,
  width = 8,
  height = 8,  
  dpi = 300
)






```



































